---
title: "Hanbook of Small Dataset Visualization Compendium"
author: "Allison Davidson"
date: ""
output: 
  html_document: 
    fig_height: 5
    fig_width: 7
    toc: true
    toc_float: TRUE
    toc_collapsed: TRUE
    toc_depth: 3
    number_sections: TRUE
    theme: lumen
---

```{r, setup, include=FALSE}
require(mosaic)    # Load additional packages here 
require(ggformula) # formula interface to ggplot2
require(tidyr)  # organize dataset
require(readr) # read in dataset
require(gridExtra) # display multiple graphs on the same "plot"/spaces
require(lubridate) # create a time varable?
require(hms) # create an hour/minute/second varaible (time)
require(forcats) # use fct_reorder( ) to order items based on summary
require(viridis) # use the viridis color scheme
library(sp) # reading in map data like shapefiles
library(raster)  # reading in map data
require(stringr) # adjusting strings like replacing characters
require(broom) # 
require(ggrepel) # label without overlapping
require(tidyverse) # use rowid_to_column
require(maps)
require(usmap)

# Some customization.  You can alter or delete as desired (if you know what you are doing).

theme_set(theme_bw()) # use to remove all the gray background
trellis.par.set(theme=theme.mosaic()) # change default color scheme for lattice

knitr::opts_chunk$set(
  tidy=FALSE,     # display code as typed
  size="small")   # slightly smaller font for code
```

All of the visualizations below give 1 or more examples of possible visualizations from the data presented in A Handbook of Small Data Sets by Hand, Daly, McConway, Lunn & Ostrowski (https://www.routledge.com/A-Handbook-of-Small-Data-Sets/Hand-Daly-McConway-Lunn-Ostrowski/p/book/9780367449667)

The visualizations all use the ggformula graphing functions (http://www.mosaic-web.org/ggformula/reference/index.html) and tidyverse functionality to format/wrangle data (https://www.tidyverse.org/).

The purpose is to provide working examples for instructors & students to implement tidyverse & ggformula graphing.


All datasets were read into R from the following GitHub repository: https://github.com/JedStephens/Handbook-of-Small-Data-Sets

The numbering system is consistent with the number for which the dataset is introduced in A Handbook of Small Data Sets.  Additionally, although a summary of the overall goal is provided here, the full description of the dataset (which is recommended to read to fully understand the visualization) is left in the book. 

# 1 Germinating Seeds

### Overall Goal:  

Visualize how different water levels & environments affect seed germination.

```{r}
# Read in data
seeds = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/GERMIN.DAT")

# Formatting data -----------------------------------------------------------------------

# renaming columns
colnames(seeds) = c("W1", "W2", "W3", "W4", "W5", "W6") 

# Add a variable for the environment (not included in the original dataset)
seeds = transform(seeds, Environment = c(rep("Uncovered Boxes", 4), rep("Covered Boxes", 4)))

# Transform the data to have variables for the water level, and number of seeds germinating
seeds = gather(seeds, "WaterLevel", "SeedsPer100", 1:6)

# Remove the * (missing value) so R recognizes number of seeds as numeric
seeds$SeedsPer100 = parse_number(seeds$SeedsPer100)

# Remove W from the water level (although this variable IS categorical (the 1-6 are just labels not quantities), the 1-6 is merely for my convenience so I could connect points across water levels in the plots below)
seeds$WaterLevel = parse_number(seeds$WaterLevel)

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

# X axis must be a number or this will not work (the line part)  

gf_jitter(SeedsPer100~WaterLevel, data=seeds, color = ~Environment, shape = ~Environment, position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.3), alpha = 0.6) %>%
  gf_summary(geom = "point", size =2, position = position_dodge(width = .3)) %>%
  gf_summary(geom = "line", linetype = ~Environment, position = position_dodge(width = .3)) %>%
  gf_refine(scale_x_discrete(limits = c(seq(1:6)))) %>%
  gf_labs(x = "Water Level", y = "Seeds per 100", title = "Number of Germinating Seeds (per 100) with Varying Water Levels & Environments") %>%
  gf_theme(theme_bw())

# Visualization 2
# ***************

# Calculate Ave Seeds directly 

ave.seeds = na.omit(seeds) %>% # get rid of the missing data
  group_by(WaterLevel, Environment) %>% # make sure like-data grouped together 
  mutate(AveSeeds = mean(SeedsPer100)) %>% # calculate & add a new variable called AveSeeds = average for the groups specified 
  dplyr::select(Environment, WaterLevel, AveSeeds) %>% # select only the variables we need (so we can remove excess later)
  unique() # since the ave is the same (repeated) for every observation within a group, only keep 1 per group

gf_line(AveSeeds~WaterLevel, data=ave.seeds, color = ~Environment, linetype = ~Environment) %>%
  gf_point(AveSeeds~WaterLevel, data=ave.seeds, color = ~Environment, shape = ~Environment) %>%
  gf_refine(scale_x_discrete(limits = c(seq(1:6)))) %>%
  gf_labs(x = "Water Level", y = "Seeds per 100", title = "Uncovered Boxes Need More Water", subtitle = "But Have About the Same Number of Germinating Seeds", caption = "Too Much Water\nAnd Everything Dies") %>%
  gf_theme(theme_bw())

```

### Notes on Visualization 1:

*Line 1: * 

  gf_jitter(SeedsPer100~WaterLevel, data=seeds, color = ~Environment, shape = ~Environment, position = position_jitterdodge(jitter.width = 0.3, dodge.width = 0.3), alpha = 0.6)

**Notes**

I like that the jitter plot allows us to see all points in every group (so we can see the variability within group and any oddities).  The color, shape, and linetype (later) difference is helpful to add multiple ways of distinguishing between the 2 Environments and hopefully allows accessible ways to see those differences.  The slight transparency of the points allows us to have the information about the raw data values in sight, but not as prominent as the connected lines.  The default jitter dodge was a bit much for me - and I wanted it to be a bit more narrow to add more separation to the groups 

*Line 2: * 

  gf_summary(geom = "point", size =2, position = position_dodge(width = .3))
  
**Notes**

Use the default summary function to calculate the average within each group and plot as a point.  The position dodge is consistent with the jitter plot so the points can be in the "center" of the cluster of points for each gorup.  The size of the points is slightly larger than the background raw data points for emphasis.  Note these are also not transparent so they are more visible than the background.
  
*Line 3: * 

  gf_summary(geom = "line", linetype = ~Environment, position = position_dodge(width = .3)) 

**Notes**

Use the default summary function to calculate the average within each group and plot as a line.  Make sure the lines are different so that even when printing in black & white the differences are visible.  Make the position dodge adjustments consistent so the lines match the points added previously.

*Line 4: *  

  gf_refine(scale_x_discrete(limits = c(seq(1:6)))) 
  
**Notes**

The default x-axis tick marks are by 2's.  This code forces R to print values 1 - 6 to better visualize each distinct water level.

*Line 5: *

  gf_labs(x = "Water Level", y = "Seeds per 100", title = "Number of Germinating Seeds (per 100) with Varying Water Levels & Environments") 

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed
  
*Line 6: * 

  gf_theme(theme_bw())

**Notes**

Remove the default gray background

### Notes on Visualization 2:

This is an alternate way to graph the summary data.  This is fine for quick comparisons, but lacks the amount of information that the jitter plot provides (where you can see all raw data in addition to the summary).  



# 2 Guessing Lenghts

### Overall Goal:  

Compare student guesses in length of the room in ft. & meters to the actual length of the room (solid line)

```{r}
# Read in data
lengths = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/LENGTHS.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# Add a new variable to describe the units the students were using (meter or ft)
lengths = transform(lengths, Unit = c(rep("Meter", 3), rep("Feet", 5)))

# Essentially make this all 1 variable
lengths = gather(lengths, "DummyV", "GuessedLength", 1:15)

# Get rid of the missing data placeholder
lengths = na.omit(lengths)

# ---------------------------------------------------------------------------------------

# Visualization 
# *************

favstats(~GuessedLength|Unit, data=lengths)

# Max feet = 94 which is equivalent to 28.65 meters
# Max meters = 40 which is equivalent to 131 feet.

# Feet Graph

feet = gf_dotplot(~GuessedLength, data = subset(lengths, Unit == "Feet"), binwidth = 2, alpha = 0.3) %>%
  gf_labs(x = "Guessed Feet", title = "Guessed Feet", y = NULL) %>%
  gf_lims(x = c(0, 147)) %>%
  gf_vline(xintercept = 43, alpha = 0.7, linetype = "dashed") %>%
  gf_text(x = 44, y = .75, label = "Actual Length = 43 ft", hjust = -0.1, size = 4) %>%
  gf_theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) 

# Meter graph

meter = gf_dotplot(~GuessedLength, data=subset(lengths, Unit == "Meter"), binwidth = 1, alpha = 0.3) %>%
  gf_labs(x = "Guessed Meters", title = "Guessed Meters", y = NULL) %>%
  gf_refine(coord_cartesian(xlim = c(0, 45))) %>%
  gf_vline(xintercept = 13.1, alpha = 0.7, linetype = "dashed") %>%
  gf_text( x = 14, y = .75, label = "Actual Length = 13.1 m", hjust=-0.1, size = 4) %>%
  gf_theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())

# Display both graphs stacked vertically

grid.arrange(feet, meter, nrow = 2)
```


  
### Notes on Visualization:

*Line 1: * 

feet = gf_dotplot(~GuessedLength, data = subset(lengths, Unit =- "Feet"), binwidth = 2, alpha = 0.3)

**Notes**

Save as an object (feet = ) so that we can stack both graphs together.  I prefer the dotplot to see each individual guess (as opposed to the histogram which summarizes more).  Because I made a separate variable for unit, I only graphed the feet here.  I adjusted the binwidth to make the dots slightly larger than the binwidth = 1 in previous graphs.  

*Line 2: * 

gf_labs(x = "Guessed Feet", title = "Guessed Feet", y = NULL)
  
**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed.  Since y isn't crucial, I removed the label.
  
*Line 3: * 

gf_refine(coord_cartesian(xlim = c(0, 206))) 

**Notes**

To make the length of each graph equivalent (1 meter = approx 3.2 ft) I forced the x-axis of meters to end at the max guessed meters & the max of ft to be the equivalent of the 63 meter max = 206 ft.

*Line 4: *  

gf_vline(xintercept = 43, alpha = 0.7, linetype = "dashed")
  
**Notes**

For ease, I added a reference line to compare the actual length of the room.  This is dashed to see elements behind.

*Line 5: *

gf_text(x = 44, y = .75, label = "Actual Length = 43 ft", hjust = -0.1, size = 4)

**Notes**

Added text close to the reference line for convenience of determining what the reference line was for.
  
*Line 6: * 

gf_theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())

**Notes**

Remove the y-axis & tick marks



# 3 Darwin Plant Matched Pairs Experiment

### Overall Goal:  

See matched pairs between cross & self fertilization where plants grown in same conditions.  Measuring final heights of plants.

```{r}
# Read in data
darwin = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/DARWIN.DAT")

# Formatting data -----------------------------------------------------------------------

# Adjust column names
colnames(darwin) = c("Pair", "Cross", "Self")

# Add a new column to be able to color-code by which fertilization method is taller
darwin = transform(darwin, Bigger = ifelse(Cross - Self > 0, "Cross", "Self"))

# Add a difference column (I wanted a variable to be able to tell R to sort by diff magnitude)
darwin = transform(darwin, diff = Cross - Self)
head(darwin)

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

gf_line(Cross~Pair, data=darwin) %>%
  gf_line(Self~Pair, data=darwin, linetype="dashed") %>%
  gf_refine(coord_cartesian(ylim = c(0,25), xlim = c(0.5,15.5)),scale_x_continuous(breaks = c(seq(1:15)))) %>%
  gf_labs(y = "Height of Plants", title = "Copmare Height of Cross & Self Fertilized Plants") %>%
  gf_text(x = 15, y = 18, label = "Self", hjust = -0.1) %>%
  gf_text(x = 15, y = 12, label = "Cross", hjust = -0.1) %>%
  gf_theme(theme_bw())

# Visualization 2
# ***************

gf_linerange(fct_reorder(as.factor(Pair), diff)~0+(Cross-Self), data=darwin, size = 4, alpha = 0.7, color=~Bigger) %>%
  gf_labs(x = "Height Difference between Cross & Self Fertilized", y = NULL, title = "Do Cross Fertilized Plants grow Taller than Self Fertilized?", color = "Which is Bigger?") %>%
  gf_theme(theme_classic()) %>%
  gf_theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
  

```

### Notes on Visualization 1:

*Line 1: * 

 gf_line(Cross~Pair, data=darwin) 

**Notes**

I used lines to better distinguish if there was a consistent trend of cross vs. self.

*Line 2: * 

 gf_line(Self~Pair, data=darwin, linetype="dashed") 
  
**Notes**

Overlay another line with a different line type
  
*Line 3: * 

 gf_refine(coord_cartesian(ylim = c(0,25), xlim = c(0.5,15.5)),scale_x_continuous(breaks = c(seq(1:15)))) 

**Notes**

Make y limits so you can see the full "height" of the plant (start at 0) and make x-axis print all values

*Line 4: *  

 gf_labs(y = "Height of Plants", title = "Copmare Height of Cross & Self Fertilized Plants")
  
**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed

*Line 5+: *

  gf_text(x = 15, y = 18, label = "Self", hjust = -0.1)
  gf_text(x = 15, y = 12, label = "Cross", hjust = -0.1) 

**Notes**

Label each line directly in plot (instead of on a separate key)
  
*Line 6: * 

  gf_theme(theme_bw())

**Notes**

Remove the default gray background

### Notes on Visualization 2:

*Line 1: * 

 gf_linerange(fct_reorder(as.factor(Pair), diff)~0+(Cross-Self), data=darwin, size = 4, alpha = 0.7, color=~Bigger)

**Notes**

Instead of plotting the raw height, just plot the height difference with clear distinction of which plant is taller.  Use fct_reorder( ) so you can see the largest to smallest.  Alter color to show difference between cross vs. self being taller.  

*Line 2: * 

  gf_theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) 
  
**Notes**

Remove y axis as it is irrelevant here.



# 4 Car Arrival Times

### Overall Goal:  

Do arrival times follow a poisson process?

```{r}
# Read in data
interval = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/INTERVAL.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# We want to make these 6 columns into 2, so I separate out each column and then stack them.
part1 = interval %>%
  dplyr::select(V1, V2)

part2 = interval %>%
  dplyr::select(V3, V4)

# Column names need to be the same in order to stack - so change the column names
colnames(part2) = c("V1", "V2")

# Missing data as placeholder removed
part3 = na.omit(interval) %>%
  dplyr::select(V5, V6)

# Column names need to be the same in order to stack - so change the column names
colnames(part3) = c("V1", "V2")

# Combine all small datasets 
new.interval = rbind(part1, part2, part3)

# I eventually want to make this a time variable - but need to drag down the hour & minute from above.  
interval = separate(new.interval, col=V2, into=c("Hour", "Minute", "Second"), fill="left")

# There may be an easier way to do this, but I essentially just wanted to keep the hour & minute from above if missing.
for(i in 1:nrow(interval)){
  if(is.na(interval$Minute[i])){
    interval$Minute[i] = interval$Minute[i-1]
  }
  if(is.na(interval$Hour[i])){
    interval$Hour[i] = interval$Hour[i-1]
  }
}

# Create a new time variable based on the values in certain columns
interval = interval %>%
  mutate(time = hms(as.numeric(Second), as.numeric(Minute), as.numeric(Hour)))

# Calculate a wait time in between each row (again, may be an easier way to do this in R)
interval = transform(interval, wait.time = 0) # initiate first wait time as 0

for(i in 2:nrow(interval)){
    interval$wait.time[i] = interval$time[i] - interval$time[i-1]
}

# ---------------------------------------------------------------------------------------

# Calc mean wait time to use as parameter in exponential dist 
favstats(~wait.time, data=interval)

# Visualizations 1 & 2
# ********************

# Histogram of wait times with exponential overlay
gf_dhistogram(~wait.time, data=interval) %>%
  gf_dist("exp", rate = 1/mosaic::mean(~wait.time, data=interval)) %>%
  gf_labs(y = NULL, x = "Wait Time between Vehicles")

# Same idea as above, just using density plot instead
gf_density(~wait.time, data=interval) %>%
  gf_dist("exp", rate = 1/mosaic::mean(~wait.time, data=interval)) %>%
  gf_labs(y = NULL, x = "Wait Time between Vehicles")

# Visualizations 3 & 4
# ********************

# Seeing each car arrival
gf_point(V1~time, data=interval) %>%
  gf_labs(y = "Car Number", x = "Arrival Time for each Vehicle")

gf_ecdf(~time, data=interval) %>%
  gf_labs(y = "Car Percentile", x = "Arrival Time for each Vehicle")
```

  


### Notes on Visualizations 1 & 2:

*Line 1: * 

 gf_dhistogram(~wait.time, data=interval)

**Notes**



*Line 2: * 

 gf_dist("exp", rate = 1/mosaic::mean(~wait.time, data=interval)) 
  
**Notes**


  
*Line 3: * 

  gf_labs(y = NULL, x = "Wait Time between Vehicles")

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed


### Notes on Visualizations 3 & 4:

*Line 1: * 

 gf_ecdf(~time, data=interval) 

**Notes**

Use of a cumulative distribtuion function.  The pros of the scatterplot is that the y-axis is the car order number whereas the CDF has y-axis the percentile.  Both see a general same trend, with the CDF function showing more of a wait time between arrivals.



# 5 Tearing factor for paper

### Overall Goal:  

Tear factor for different pressures in paper making (where pressure is perhaps on log scale).

```{r}
# Read in data
paper = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/TEARING.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# Gathering all the tear factors for each pressure and then dropping the dummy variable (dummyV)
paper = gather(paper, "dummyV", "TearFactor", 2:5) %>%
  dplyr::select(V1, TearFactor)

# Change the first column name
colnames(paper)[1] = "Pressure"

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

# Just for curiosity - plot as original.  

gf_point(TearFactor~Pressure, data=paper, alpha = 0.5)

# Visualization 2
# ***************

# Plot on log scale as suggested

gf_point(TearFactor~log(Pressure), data=paper, alpha = 0.5) %>%
  gf_lm(color = "black", linetype = "dotted") %>%
  gf_labs(y = "Tear Factor", x = "Log Pressure")
```

### Notes on Visualization:

*Line 1: * 

 gf_point(TearFactor~log(Pressure), data=paper, alpha = 0.5) 

**Notes**

Scatterplot with tear factor and log(pressure) (printed on log scale as requested)

*Line 2: * 

 gf_lm(color = "black", linetype = "dotted") 
  
**Notes**

Add trendline and adjust line type so it is not quite as dominant
  
*Line 3: * 

 gf_labs(y = "Tear Factor", x = "Log Pressure")

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed





# 6 Rubber Abrasion Loss

### Overall Goal:  

Goal is to predict or model abrasion loss based on both hardness or tensile strength possibly in a multiple linear regression.

```{r}
# Read in data
rubber = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/ABRASION.DAT")

# Formatting data -----------------------------------------------------------------------

# JUst change colomn names
colnames(rubber) = c("AbrasionLoss", "Hardness", "TensileStrength")
head(rubber)

# ---------------------------------------------------------------------------------------

# Just checking for a general relationship between both hardness & tensile strength on abrasion

gf_point(AbrasionLoss~Hardness, data=rubber)
gf_point(AbrasionLoss~TensileStrength, data=rubber)

# Check for multicolinearity (no patter = no worries!!)

gf_point(Hardness~TensileStrength, data=rubber)

# Create the model

rubber.model = lm(AbrasionLoss~Hardness+TensileStrength, data=rubber)
summary(rubber.model)

# Make a function so we can add regression lines on the plot

f = makeFun(rubber.model)

gf_point(AbrasionLoss~TensileStrength, data=rubber, size = ~Hardness)

# Visualization 
# *************

gf_point(AbrasionLoss~Hardness, data=rubber, size = ~TensileStrength, alpha = 0.4) %>%
  gf_fun(f(TensileStrength = 120, Hardness)~Hardness, col=~"120", linetype = "dashed") %>%
  gf_fun(f(TensileStrength = 150, Hardness)~Hardness, col=~"150", linetype = "dashed") %>%
  gf_fun(f(TensileStrength = 180, Hardness)~Hardness, col=~"180", linetype = "dashed") %>%
  gf_fun(f(TensileStrength = 210, Hardness)~Hardness, col=~"210", linetype = "dashed") %>%
  gf_refine(scale_color_viridis(discrete=TRUE, direction = -1)) %>%
  gf_labs(y = "Amount of Rubber Loss due to Abrasion", col = "Tensile Strength", size = "Tensile Strength", title = "How Tensile Strength & Hardness effect Abrasion") %>%
  gf_theme(theme_bw())
```

### Notes on Visualization:

*Line 1: * 

 gf_point(AbrasionLoss~Hardness, data=rubber, size = ~TensileStrength, alpha = 0.4) 

**Notes**

Create a scatterplot where points are sized based on tensile strength with slight transparency to we can see overlap.

*Line 2: * 

  gf_fun(f(TensileStrength = 120, Hardness)~Hardness, col=~"120", linetype = "dashed") 
  gf_fun(f(TensileStrength = 150, Hardness)~Hardness, col=~"150", linetype = "dashed") 
  gf_fun(f(TensileStrength = 180, Hardness)~Hardness, col=~"180", linetype = "dashed")
  gf_fun(f(TensileStrength = 210, Hardness)~Hardness, col=~"210", linetype = "dashed") 
  
**Notes**

Add linear model functions (lines) for each of the tensile strengths where we color each one differently.  Using the col=~"120" item it will automatically label based on the value you give ("120").  I used dashed lines so they don't overpower the graph and can see slightly through them.
  
*Line 3: * 

 gf_refine(scale_color_viridis(discrete=TRUE, direction = -1)) 

**Notes**

I like the color scheme of the autmoatic colors in the viridis package.  I wanted the yellow for the "smallest" value, so I put direction = -1 to reverse the default order of colors.

*Line 4: *

 gf_labs(y = "Amount of Rubber Loss due to Abrasion", col = "Tensile Strength", size = "Tensile Strength", title = "How Tensile Strength & Hardness effect Abrasion")

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed
  
*Line 5: * 

  gf_theme(theme_bw())

**Notes**

Remove the default gray background


# 7 England Water

### Overall Goal:  

See first how the calcium level affects mortality and then also see how geographical area is related (if at all).

```{r}
# Read in data
water = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/WATER.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# The 4 columns should instead be just 2 so split up the columns into 2 different datasets
water.part1 = na.omit(water) %>%
  dplyr::select(V1, V2) 

water.part2 = water %>%
  dplyr::select(V3, V4)

# Change the column names so we can stack the data
colnames(water.part2) = c("V1", "V2")

# Stack the datasets 
new.water = rbind(water.part1, water.part2)

# Change the names of the variables
colnames(new.water) = c("Mortality", "Calcium")

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

gf_point(Mortality~Calcium, data=new.water) %>%
  gf_text(x = 15, y = 2000, hjust = 0, label = "More people dying") %>%
  gf_text(x = 100, y = 1100, hjust = 0, label = "Less people dying") %>%
  gf_labs(title = "Less calcium leads to more death") %>%
  gf_theme(theme_bw())

# Adding Something Extra ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# I created a dataset to identify the town, county the town is in, and lat & long of each city
England_Cities <- read_csv("/home/allisondavidson/Data Visualization/Handbook of Small Datasets/England Cities.csv")

# Merge all the data from the original dataset & water dataset
all.info = data.frame(new.water, England_Cities)

# download uk data level 2 from GADM  
uk <- getData('GADM', country='GBR', level = 2)  

# Keep only England
england = subset(uk, NAME_1 == "England")

# Get the correct ID for reach county in England
poly.id = NULL

for(i in 1:118){
  poly.id = c(poly.id, england@polygons[[i]]@ID)
}

# Match up the county names & IDs
id = poly.id
County = england$NAME_2
eng.names = data.frame(id, County)

# Tidy a shape file so we can use it in ggplot
map.england = tidy(england)

# Join map info with name info with the english names & water data
map.england = left_join(map.england, eng.names, by="id")
map.england = left_join(map.england, all.info, by="County")

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Visualization 2
# ***************

gf_point(lat1~long2, data=all.info, size = ~Calcium, color = ~Mortality) %>%
  gf_polygon(lat~long, data=map.england, group=~group, fill=NA, color="black", size = 0.1) %>%
  gf_refine(theme_map(), coord_fixed(1), scale_color_distiller(palette = "Reds", direction = 1)) 
  


# Visualization 3 (Not Included)
# ******************************


# This is other code that works, but not ggplot

#library(leaflet)
# creating a colour palette that provides a diff colour for regions
# in different country i.e., Scotland, Ireland, Wales, etc.  
#pal <- colorFactor("Reds", uk$ID_2)
#leaflet(uk) %>% 
#  addPolygons(color = "#444444", weight = 1, smoothFactor = 0.5,
#              opacity = 1.0, fillOpacity = 0.5,
#              #fillColor = ~pal(ID_2),
#              highlightOptions = highlightOptions(color = "white", weight =2,
#                                                  bringToFront = TRUE),
#              label = ~paste0(NAME_2, ", ", NAME_1))  

```

 
### Notes on Visualization 1:

*Line 1: * 

 gf_point(Mortality~Calcium, data=new.water)

**Notes**

Create a scatterplot to see how the calcium level affects mortality.

*Line 2: * 

 gf_text(x = 15, y = 2000, hjust = 0, label = "More people dying") 
 gf_text(x = 100, y = 1100, hjust = 0, label = "Less people dying") 
  
**Notes**

Add some annotations to get an idea of what the graph is showing
  
*Line 3: * 

 gf_labs(title = "Less calcium leads to more death") 

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed
  
*Line 4: * 

  gf_theme(theme_bw())

**Notes**

Remove the default gray background


### Notes on Visualization 2:

*Line 1: * 

 gf_point(lat1~long2, data=all.info, size = ~Calcium, color = ~Mortality) 


**Notes**

Start with a layer of the points for each city at their geographic location, sized by calcium and colored by mortality.

*Line 2: * 

 gf_polygon(lat~long, data=map.england, group=~group, fill=NA, color="black", size = 0.1)
  
  
**Notes**

Add on the map of england split up by county.
  
*Line 3: * 

 gf_refine(theme_map(), coord_fixed(1), scale_color_distiller(palette = "Reds", direction = 1)) 

**Notes**

Make the theme white background and fix the coordinates so the scale is appropriate.  I wanted something red for mortality and have the highest values (most death rates) to be the darkest red, so negated the direction from the default.


# 8 Cement

### Overall Goal:  

Predict the tensile strength of cement based on curing days.  

```{r}
# Read in data

# Formatting data -----------------------------------------------------------------------

cement = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/CEMENT.DAT", header = FALSE)

# Gather all the Tensile Strength Info into a single variable with corresponding curing days
cement = gather(cement, "DummyV", "TensileStrength", 2:6) %>%
  dplyr::select(V1, TensileStrength)

# Change the name for the first column
colnames(cement)[1]="CuringDays"

# Omit any missing data
cement = na.omit(cement)
# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_point(TensileStrength~CuringDays, data=cement)

cement = transform(cement, recip.days = 1/CuringDays)
reg.cement = lm(log(TensileStrength)~recip.days, data=cement)
summary(reg.cement)

gf_point(log(TensileStrength)~(1/CuringDays), data=cement) %>%
  gf_fun(3.68-1.14*recip.days~recip.days) %>%
  gf_labs(title = "Plotting Cement Tensile Strength based on Curing Days", subtitle = "Log and Reciprocal transformations")

```

### Notes on Visualization:

*Line 1: * 

 gf_point(log(TensileStrength)~(1/CuringDays), data=cement) 


**Notes**

Basic scatterplot but use the transformations suggested (log of tensile strength and reciprocal of curing days).  

*Line 2: * 

  gf_fun(3.68-1.14*recip.days~recip.days) 

**Notes**

I could not get the makeFun( ) function to actually plot - so I forced the function based on the regression output.
  
*Line 3: * 

  gf_labs(title = "Plotting Cement Tensile Strength based on Curing Days", subtitle = "Log and Reciprocal transformations")

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed

# 9 Rat Weight Gain

### Overall Goal:  

See the effect of various amounts of protein on weight gain in rats.  Protein comes from beef or cereal and is low or high dose.

```{r}
# Read in data

rats = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/WEIGHT.DAT")

# Formatting data -----------------------------------------------------------------------

# Each column has different source & amount, so split them all out and add the source & amount as variables
beef.low = dplyr::select(rats, "V1")
beef.high = dplyr::select(rats, "V2")
cereal.low = dplyr::select(rats, "V3")
cereal.high = dplyr::select(rats, "V4")

# Adding the appropriate source & amount of each type of protein
beef.low = transform(beef.low, Source = "Beef", Amount = "Low")
colnames(beef.low)[1] = "WeightGain"

beef.high = transform(beef.high, Source = "Beef", Amount = "High")
colnames(beef.high)[1] = "WeightGain"


cereal.low = transform(cereal.low, Source = "Cereal", Amount = "Low")
colnames(cereal.low)[1] = "WeightGain"

cereal.high = transform(cereal.high, Source = "Cereal", Amount = "High")
colnames(cereal.high)[1] = "WeightGain"

# Bind all columns together
rats.tidy = rbind(beef.low, beef.high, cereal.low, cereal.high)

# Force the order of the amounts so that low is first
rats.tidy$Amount = factor(rats.tidy$Amount, levels = c("Low", "High"))
# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

gf_boxplot(WeightGain~Amount|Source, data=rats.tidy, fill=~Amount) %>%
  gf_sina(WeightGain~Amount|Source, data=rats.tidy, alpha = 0.3) %>%
  gf_labs(y = "Weight Gain", x = "Amount of Protein", title = "Weight Gain in Rats") %>%
  gf_theme(theme_bw())

# Visualization 2
# ***************

gf_jitter(WeightGain~Amount, data=rats.tidy, color=~Source, alpha = 0.4, shape = ~Source, position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.2)) %>%
  gf_line(WeightGain~Amount, color = ~Source, data=rats.tidy, group=~Source, stat="summary", linetype = ~Source, size = 2) %>%
  gf_labs(y = "Weight Gain", x = "Amount of Protein", title = "Weight Gain in Rats") %>%
  gf_text(data = subset(rats.tidy, Amount == "High"), label = ~Source, stat = "summary", hjust = -0.1) %>%
  gf_theme(legend.position = "none")

```


### Notes on Visualization 2:

*Line 1: * 

 gf_jitter(WeightGain~Amount, data=rats.tidy, color=~Source, alpha = 0.4, shape = ~Source, position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.2)) 

**Notes**

Create a jitter plot with the dots transparent so you can see the variability, but it is not the most prominant area of the graph.  Change the color and shape so it is easily recognizable the different groups.  Slightly adjust the position of each group so they don't overlap and have narrow jitter so the groups are "tight" together.

*Line 2: * 

 gf_line(WeightGain~Amount, color = ~Source, data=rats.tidy, group=~Source, stat="summary", linetype = ~Source, size = 2)
  
**Notes**

Add reference lines similar to an interaction plot connecting the means of low & high amounts of each type of protein.  Color & change line type for each type of protein so they are more distinguishable.  
  
*Line 3: * 

 gf_labs(y = "Weight Gain", x = "Amount of Protein", title = "Weight Gain in Rats")

**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed

*Line 4: *  

 gf_text(data = subset(rats.tidy, Amount == "High"), label = ~Source, stat = "summary", hjust = -0.1) 
  
**Notes**

Instead of having the legend indicating the color/line type of each type of protein - label each line specifically.  Make it one less thing the eye has to track.  

*Line 5: *

 gf_theme(legend.position = "none")

**Notes**

Remove the default legend
  


# 10 Weight of Chickens

### Overall Goal:  

See if drug added to chicken feed (at low or high dose) affects weight gain.  Groups of chickens are blocked together in the same coop under the 3 conditions (control, low & high dose).

```{r}
# Read in data

chicken = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/CHICKENS.DAT")

# Formatting data -----------------------------------------------------------------------

# Format column names
colnames(chicken) = c("Block", "Control", "Low", "High")

# Create variables for treatment and weight to graph appropriately
chicken2 = gather(chicken, "Treatment", "Weight", 2:4)

# Force order of factor levels
chicken2$Treatment = factor(chicken2$Treatment, levels = c("Control", "Low", "High"))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_line(Weight~Treatment, data=chicken2, group=~Block, alpha = 0.6) %>%
  gf_labs(y = "Weight of Chickens in lbs", x = "Treatment Level", title = "Drug Additive to Increase Weight in Chickens") %>%
  gf_theme(theme_bw())

```

### Notes on Visualization:

*Line 1: * 

 gf_line(Weight~Treatment, data=chicken2, group=~Block, alpha = 0.6) 

**Notes**

Use lines to show the connection of chickens across treatment groups within the same block.  Notice that most have a steady incline (showing more drug = more weight) but not all.  

*Line 2: * 

 gf_labs(y = "Weight of Chickens in lbs", x = "Treatment Level", title = "Drug Additive to Increase Weight in Chickens")
  
**Notes**

For convenience, adjust the axis & title labels to better understand the variables & data graphed
  
*Line 3: * 

 gf_theme(theme_bw())

**Notes**

Remove the default gray background


# 11 Flicker Drowsiness in Drugs

### Overall Goal:  

Test if the kind of drug is affecting drowsiness in a patient.  

```{r}
# Read in data
flicker = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/FLICKER.DAT")

# Formatting data -----------------------------------------------------------------------

# Grab the subject number, Flicker & treatment for Day 1
Day1 = flicker %>%
  dplyr::select(V1, V2, V3) %>%
  transform(Day = 1)

# Adjust the column names
colnames(Day1) = c("Subject", "Flicker", "Treatment", "Day")

# Grab the subject number, Flicker & treatment for Day 2
Day2 = flicker %>%
  dplyr::select(V1, V4, V5) %>%
  transform(Day = 2)

colnames(Day2) = c("Subject", "Flicker", "Treatment", "Day")

# Grab the subject number, Flicker & treatment for Day 3
Day3 = flicker %>%
  dplyr::select(V1, V6, V7) %>%
  transform(Day = 3)

colnames(Day3) = c("Subject", "Flicker", "Treatment", "Day")

# Combine all three days together in one dataset
flicker = rbind(Day1, Day2, Day3)

# Recode the treatments for easier readability
flicker$Treatment = recode(flicker$Treatment, '(A)' = "New Drug", '(B)' = "Placebo", '(C)' = "Old Drug")
# ---------------------------------------------------------------------------------------

# Visualizations
# **************

gf_line(Flicker~Treatment, data=flicker, group = ~Subject) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(title = "Drowsiness (Flicker) Effects from Different Drugs")

gf_boxplot(Flicker~as.factor(Day)|Treatment, data=flicker) %>%
  gf_labs(x = "Day", title = "Drowsiness (Flicker) Effects from Different Drugs") %>%
  gf_theme(theme_bw())


gf_line(Flicker~Treatment, data=flicker, group = ~Subject, label = ~Day) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(title = "Drowsiness (Flicker) Effects from Different Drugs") +
  geom_text_repel()

```

### Notes on Visualization 1:

*Line 1: * 

gf_line(Flicker~Treatment, data=flicker, group = ~Subject)

**Notes**

The line graph was used here to show the link between treatments for each subject.  It is noted that there are different patterns for different people, so it's not a clear-cut effect across people.


### Notes on Visualization 2:

*Line 1: * 

gf_boxplot(Flicker~as.factor(Day)|Treatment, data=flicker)

**Notes**

The boxplots show the effect of day for each treatment.  The downside is that you lose the link between treatments for the same subject.

### Notes on Visualization 3:

*Lines 1 & : * 

  gf_line(Flicker~Treatment, data=flicker, group = ~Subject, label = ~Day) 
  geom_text_repel()

**Notes**

The label = ~Day adds the day number to the plot.  The geom_text_repel( ) tries to make sure these labels don't overlap.  The purpose of this was to see if the really low/odd values in the old drug were due to the day being 1 (which we can see from the boxplot is significantly lower than days 2 & 3)

# 12 Effect of Ammonium Chloride on Yield

### Overall Goal:  

Explore different grades & amounts of ammonium chloride in a 2^3 factor design (2 production units).

```{r}
# Read in data
#ammonium = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/CHLORIDE.DAT")

# Too many special characters - can't quickly figure out how to skip them - so entering data dynamically

# Formatting data -----------------------------------------------------------------------

# Entering all columns

col1 = c("low", "low", 1, 155, NA, NA, 164)
col2 = c("high", "low", 1, NA, 162, 171, NA)
col3 = c("low", "high", 1, NA, 168, 175, NA)
col4 = c("high", "high", 1, 157, NA, NA, 171)
col5 = c("low", "low", 2, NA, 156, 161, NA)
col6 = c("high", "low", 2, 150, NA, NA, 153)
col7 = c("low", "high", 2, 152, NA, NA, 162)
col8 = c("high", "high", 2, NA, 161, 173, NA)

# Combine as rows instead of columns (transpose the original data)

ammonium = data.frame(rbind(col1, col2, col3, col4, col5, col6, col7, col8))

# Add column names

colnames(ammonium) = c("AmmoniumQuality", "AmmoniumAmount", "ProdUnit", "Block1", "Block2", "Block3", "Block4")

# Make block & Yeild separate variables (in order to graph differently)

ammonium2 = gather(ammonium, "Block", "Yield", 4:7)

# Force order of low & high

ammonium2$AmmoniumQuality = factor(ammonium2$AmmoniumQuality, levels = c("low", "high"))
ammonium2$AmmoniumAmount = factor(ammonium2$AmmoniumAmount, levels = c("low", "high"))

# Force R to treat Yield as numeric
ammonium2$Yield = as.numeric(ammonium2$Yield)

ammonium2$Block = parse_number(ammonium2$Block)

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

gf_point(Yield~AmmoniumAmount|AmmoniumQuality, data=ammonium2, color = ~ProdUnit, shape = ~ProdUnit) %>%
  gf_text(label = ~Block, hjust = 2) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(x = "Ammonium Amount", title = "Yield on Differing Ammonium Amounts & Quality", shape = "Production\n Unit", color = "Production\n Unit", subtitle = "Panels separate Ammonium Quality")

# Visualization 2
# ***************

gf_text(Yield~AmmoniumAmount|AmmoniumQuality, data=ammonium2, color = ~ProdUnit, label = ~Block) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(x = "Ammonium Amount", title = "Yield on Differing Ammonium Amounts & Quality", color = "Production\n Unit", subtitle = "Panels separate Ammonium Quality")

```

### Notes on Visualization 1:

*Line 1: * 

 gf_point(Yield~AmmoniumAmount|AmmoniumQuality, data=ammonium2, color = ~ProdUnit, shape = ~ProdUnit) 
  

**Notes**

I am not convinced this is the best way to visualize this data - but I wanted a way to see each of the small number of points and label the block (so all information is captured in one graph).  This isn't always helpful, but it was managable to do here and becuase there were not clear differences in the yield (that I noticed) - I found it helpful.

I wanted to keep the small number of points very close together to group easily so used the gf_point command instead of the gf_jitter.  I felt the amount would be more desirable to compare directly so kept those on the same panel (low vs. high) and then separated panels out by quality.  

The production unit & block were not as crucial - but wanted them taken into account in some way.  I also wanted these somewhat accessible to color-absent graphics so changed both the color & shape of production unit.

*Line 2: * 

 gf_text(label = ~Block, hjust = 2)
  
**Notes**

I thought about connecting the points for each block - but it doesnt really make sense to connect the points.  Instead I thought it made more sense if we wanted to see if there was a block effect, we could label each point with the block.  An alternative is to have the block number be the point instead of a dot.  
  

### Notes on Visualization 2:

*Line 1: * 

gf_text(Yield~AmmoniumAmount|AmmoniumQuality, data=ammonium2, color = ~ProdUnit, label = ~Block) 

**Notes**

This is an updated version of the previous graph where the points are the block number instead of points.  Less cluttered all together.


# 13 Dishwashing Detergent

### Overall Goal:  

Compare 9 different detergents in terms of how many dishes they can wash before the suds dissapear.  

```{r}
# Read in data

# First I saved the raw data as a .txt file on my computer.  
# Then, I uploaded the raw file & found all the ? and replaced with NA to get this to read.

dish = read.delim("/home/allisondavidson/Data Visualization/Handbook of Small Datasets/DISHWASH.DAT.txt", header=FALSE)

# Formatting data -----------------------------------------------------------------------

# Gather data to be in columns

dish = gather(dish, "Detergent", "DishesWashed", 2:10)

# Adjust name of first column

colnames(dish)[1] = "Block"

# The numbers of detergent was off by 1, so grab the number and subtract & also make this a factor

dish$Detergent = as.factor(parse_number(dish$Detergent) - 1)

# Force the order for which the detergent is plotted based on the median dishes washed

dish.new = na.omit(dish) %>%
  mutate(Detergent = fct_reorder(Detergent, DishesWashed, .fun = "median"))

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

gf_jitter(DishesWashed~Detergent, data=dish.new, width = 0.2, alpha = 0.4) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(y = "Number of Dishes Washed", title = "Compare Detergents")

# Visualization 2
# ***************

gf_boxplot(DishesWashed~Detergent, data=dish.new, width = 0.2, alpha = 0.4) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(y = "Number of Dishes Washed", title = "Compare Detergents")

```

### Notes on Visualization 1:

*Line 1: * 

 gf_jitter(DishesWashed~Detergent, data=dish.new, width = 0.2, alpha = 0.4)

**Notes**

This is actually a very simple visualization - what is more important is the organization of the data and forcing the detergent order by dishes washed (median).  The width = 0.2 also helps keep the points close together.

### Notes on Visualization 2:

*Line 1: * 

gf_boxplot(DishesWashed~Detergent, data=dish.new, width = 0.2, alpha = 0.4)

**Notes**

An alternative approach doing the same thing, just less dots - a boxplot (can also make them thinner usind width = 0.2).  You can better see the variability here than when there are too many dots.

# 14 CPU Failures

### Overall Goal:  

Model the time to failure possibly using a nonhomogeneous Poisson process with linearly or exponentially decreaseing failure intensity.

```{r}
# Read in data

cpu = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/SOFTWARE.DAT", header=FALSE)

# Formatting data -----------------------------------------------------------------------

cpu = gather(cpu, "DummyV", "TimeOfFailure") %>%
  dplyr::select(TimeOfFailure) %>%
  rowid_to_column("Index")

# Calculate a wait time in between each row (again, may be an easier way to do this in R)

cpu = transform(cpu, time.to.failure = 0) # initiate first wait time as 0

for(i in 2:nrow(cpu)){
    cpu$time.to.failure[i] = cpu$TimeOfFailure[i] - cpu$TimeOfFailure[i-1]
}

# ---------------------------------------------------------------------------------------

# Visualization (Time of Failure)
# ***************

gf_histogram(~TimeOfFailure, data=cpu)

# Visualization (Time until next failure)

gf_point(time.to.failure~Index, data=cpu, alpha = 0.4) %>%
  gf_theme(theme_bw()) %>%
  gf_labs(y = "Time Until Failure", x = "Failure Number (Index)", title = "Modeling Time until Failure")

```

### Notes on Visualization:

*Line 1: * 

gf_histogram(~TimeOfFailure, data=cpu)

**Notes**

Here I just wanted to get an idea of how many failures were happening over time.  It can be seen that they start out with a lot, then they taper off to a point.

### Notes on Visualization:

*Line 1: * 

gf_point(time.to.failure~Index, data=cpu, alpha = 0.4)
  
**Notes**

Here we can see the wait time between failures and how there is a huge spread later on.  The key thing here is not the visualization so much as the wrangling of the data to get the time between points (for loop was used).
  



# 15 Piston Ring Failures

### Overall Goal:  

Is there a relationship between the compressor & leg?

```{r}
# Read in data

piston = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/PISTON.DAT")

# Formatting data -----------------------------------------------------------------------

# Change column names

colnames(piston) = c("North", "Center", "South", "Total")

# Add ID variable and create 2 variables each for Leg & Failures

piston = piston %>%
  rowid_to_column("Compressor") %>%
  gather("Leg", "Failures", 2:4)

# Adjust the default order

piston$Leg = factor(piston$Leg, levels = c("North", "Center", "South"))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

# Raw Counts
gf_col(Failures~Compressor, data=subset(piston, Compressor != 5), fill=~Leg)

# Proportion
gf_col(Failures/Total~Compressor, data=subset(piston, Compressor != 5), fill=~Leg) %>%
  gf_labs(y = "Proportion of Failures", title = "Number of Failures by Compressor & Leg") %>%
  gf_theme(theme_bw()) 
```

### Notes on Visualization:

*Line 1: * 

gf_col(Failures/Total~Compressor, data=subset(piston, Compressor != 5), fill=~Leg) 

**Notes**

Use the gf_col( ) instead of bargraph (etc) when you want to use values of the data to determine the height of the bars/columns.  I had R dynamically calculate the percent of failure so all bars were the same height and you can compare proportions across all compressors.  I also forced the order of the Leg positions.


# 16 Strength of Chemical Pastes 

### Overall Goal:  

See if there is differences between casks and batches of chemical paste.

```{r}
# Read in data

paste = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/PASTES.DAT")

# Formatting data -----------------------------------------------------------------------

# Separate out the 3 different casks to eventaully combine later

Cask1 = paste %>%
  dplyr::select(V1, V2, V3) %>%
  gather("DummyV", "Strength", 2:3) %>%
  mutate(Cask = 1)

Cask2 = paste %>%
  dplyr::select(V1, V4, V5) %>%
  gather("DummyV", "Strength", 2:3) %>%
  mutate(Cask = 2)

Cask3 = paste %>%
  dplyr::select(V1, V6, V7) %>%
  gather("DummyV", "Strength", 2:3) %>%
  mutate(Cask = 3)

# Combine all casks to a new tidy dataset

paste.long = rbind(Cask1, Cask2, Cask3) 

# Rename the first variable

colnames(paste.long)[1] = "Batch"
# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_point(Strength~fct_reorder(as.factor(Batch), Strength), data=paste.long, color=~as.character(Cask), alpha = 0.3) %>%
#  gf_line(Strength~fct_reorder(as.factor(Batch), Strength), data=paste.long, group = ~Cask, stat = "summary") %>%
  gf_labs(x = "Batch Number", color = "Cask", title = "Strength of Chemical Paste between Batches & Casks") %>%
  gf_theme(theme_bw())

gf_boxplot(Strength~as.factor(Batch), data=paste.long, width = 0.2) %>%
  gf_labs(x = "Batch Number", title = "Variations in Strength Between Batches") %>%
  gf_theme(theme_bw())
```

### Notes on Visualization:

*Line 1: * 

gf_boxplot(Strength~as.factor(Batch), data=paste.long, width = 0.2)

**Notes**

I used a scatterplot (above) but I think the main point of the article is to look between batches - and the 3 different casks are of less importance than the differences between batches.  Or perhaps variability within batches?  In either case, the boxplot was thought to better reflect both points.  The scatterplot is kept in in case cask is of any interest.



# 17 Percent Fat

### Overall Goal:  

Explore the percent body fat with age between gender identity.  Note the terrible representation of gender among ages.

```{r}
# Read in data

fat = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/HUMAN.DAT")

# Formatting data -----------------------------------------------------------------------

# rename variables

colnames(fat) = c("Age", "PercentFat")

# add the variable for Sex as it was not included in the dataset

fat = transform(fat, Sex = c("M", "F", "M", "M", "F", "F", "M", rep("F", 11)))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_text(PercentFat~Age, data=fat, label = ~Sex, color = ~Sex) %>%
  gf_theme(legend.position = "none") %>%
  gf_labs(y = "Percent Body Fat", title = "Relationship Between Percent Fat & Age", subtitle = "Terrible representation of Gender Across Ages") 

```

### Notes on Visualization:

*Line 1: * 

gf_text(PercentFat~Age, data=fat, label = ~Sex, color = ~Sex)

**Notes**

I figured it was more interesting to print the Ms and Fs to represent Male/Female rather than just a color.

*Line 2: * 

gf_theme(legend.position = "none") 

**Notes**

Because each point is labeled, I didn't think we needed the legend for Sex.




# 18 Motion Sickness

### Overall Goal:  

See the survival times between the different frequencies of motion to test for time until vomit.

```{r}
# Read in data

motion = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/MOTION.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# Separate out the low & high frequency columns to combine later

low.freq = motion %>%
  dplyr::select(V1, V2) %>%
  mutate(Freq = "low")

colnames(low.freq) = c("Subject", "TimeToVomit", "Freq")

high.freq = motion %>%
  dplyr::select(V3, V4) %>%
  mutate(Freq = "high")

colnames(high.freq) = c("Subject", "TimeToVomit", "Freq")

# Combine the two datasets, add in where there was a censored value (if desired for later use) and then remove the * so TimeToVomit is numeric.

motion.new = rbind(low.freq, high.freq) %>%
  mutate(Censored = ifelse(str_detect(TimeToVomit, "\\*") & parse_number(TimeToVomit) < 120, "Yes", "No")) %>%
  mutate(TimeToVomit = parse_number(TimeToVomit))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

theme_set(theme_bw())

gf_ecdf(~TimeToVomit, data=motion.new, color = ~Freq) %>%
  gf_labs(y = "Percent of People that Have Vomitted", x = "Minutes Passed", title = "Motion Sickness") 

```

### Notes on Visualization:

*Line 1: * 

gf_ecdf(~TimeToVomit, data=motion.new, color = ~Freq)

**Notes**

I really wanted the inverse CDF function (the "survival" analysis or Kaplan Meier plot) but I couldn't figure out how to get the inverse CDF.  So, we're just going with the percent that have vomitted on y instead of the percent that have  not vomited.

UPDATE:  I coud use gf_step( ) to create the plot I want, but I have to calculate the proportion to be able to plot it.  Not ideal.  


# 19 Plum Root Cuttings

### Overall Goal:  

Compare the length and time on the survival rate of plum root cuttings.

```{r}
# Read in data

plum = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/PLUM.DAT")

# Formatting data -----------------------------------------------------------------------

# Update column names

colnames(plum) = c("Dead", "Alive", "Total")

# Add the Length & Time variables (since they aren't included yet) and then make Survival & Count variables to plot

plum = plum %>%
  mutate(Length = c("long", "long", "short", "short")) %>%
  mutate(Time = c("at once", "in spring", "at once", "in spring")) %>%
  gather("Survival", "Count", 1:2)

# Switch the order of the factor levels so it plots reverse default order

plum$Survival = factor(plum$Survival, levels = c("Dead", "Alive"))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(Count~Length|Time, data=plum, fill=~Survival)

```

### Notes on Visualization:

*Line 1: * 

gf_col(Count~Length|Time, data=plum, fill=~Survival)

**Notes**

A quick & easy column chart to compare the length of cuttings & when they are planted.  I wanted the dead values on "top" and red and the alive values on the bottom & green, so I switched the default order of the values.  It seems like the live plants would be growing, so it made sense for me that Alive would be at the bottom & greenish.



# 20 Wearing Glasses

### Overall Goal:  

See if there is a relationship between those that wear glasses & those that don't between delinquents & control.

```{r}
# Read in data

glasses = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/GLASSES.DAT")

# Formatting data -----------------------------------------------------------------------

# Adjust column names

colnames(glasses) = c("Delinquents", "NonDelinquents", "Total")

# Add column for Glasses & create 2 new variables Subject & Count by wrangling the table.

glasses = glasses %>%
  mutate(Glasses = c("Yes", "No", "Total")) %>%
  gather("Subject", "Count", 1:2)

# Minor adjustment but recode the variable names so it reads easier.

glasses$Subject = recode(glasses$Subject, "NonDelinquents" = "Non Delinquents")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(Count~Subject, data=subset(glasses, Glasses != "Total"), fill=~Glasses)

```

### Notes on Visualization:

*Line 1: * 

gf_col(Count~Subject, data=subset(glasses, Glasses != "Total"), fill=~Glasses)

**Notes**

Another super simple column chart.  The default actually looks pretty good to me (Yes being teal & No being red/bad).  We could make these percentages, but it wasn't worth the hastle to me.


# 21 Isatin Derivatives

### Overall Goal:  

Explore a 2^4 factorial design without any replacates.  

```{r}
# Read in data

isatin = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/ISATIN.DAT")

# Formatting data -----------------------------------------------------------------------

# Separate & grab each column & add the temperature & amount.  Acid strength & reaction time will be the same across all columns but not included in the dataset, so added here.  

temp60 = isatin %>%
  dplyr::select(V1) %>%
  mutate(Temperature = "60 C",
         Amount = "35 ml",
         AcidStrength = c("87 %", "87 %", "93 %", "93 %"),
         ReactionTime = c(15, 30, 15, 30))

colnames(temp60)[1] = "Yield"

temp60.45 = isatin %>%
  dplyr::select(V2) %>%
  mutate(Temperature = "60 C",
         Amount = "45 ml",
         AcidStrength = c("87 %", "87 %", "93 %", "93 %"),
         ReactionTime = c(15, 30, 15, 30))

colnames(temp60.45)[1] = "Yield"

temp70 = isatin %>%
  dplyr::select(V3) %>%
  mutate(Temperature = "70 C",
         Amount = "35 ml",
         AcidStrength = c("87 %", "87 %", "93 %", "93 %"),
         ReactionTime = c(15, 30, 15, 30))

colnames(temp70)[1] = "Yield"

temp70.45 = isatin %>%
  dplyr::select(V4) %>%
  mutate(Temperature = "70 C",
         Amount = "45 ml",
         AcidStrength = c("87 %", "87 %", "93 %", "93 %"),
         ReactionTime = c(15, 30, 15, 30))

colnames(temp70.45)[1] = "Yield"

# Combine all datasets

isatin = rbind(temp60, temp60.45, temp70, temp70.45)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_line(Yield~as.factor(ReactionTime)|Temperature~Amount, data=isatin, group = ~AcidStrength, linetype = ~AcidStrength) %>%
  gf_labs(x = "Reaction Time (min)", linetype = "Acid Strength", title = "Yeild of Isatin Derivatives")


```


### Notes on Visualization:

*Line 1: * 

gf_line(Yield~as.factor(ReactionTime)|Temperature~Amount, data=isatin, group = ~AcidStrength, linetype = ~AcidStrength)

**Notes**

Much of the work on this was formatting the dataset.  It was a lot of creating the categories - and I purposely made the categories with units to try to help the reader understand what the values were referring to (too many raw numbers).  I chose a simple line plot to be able to see all 4 variables on the same plot to compare everything together.  


# 22 Fruitflies

### Overall Goal:  

Explore different treatments for fruitflie deterrents.  

```{r}
# Read in data

flies = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/FRUITFLY.DAT")

# Formatting data -----------------------------------------------------------------------

# Add appropriate column names

colnames(flies) = c("Resistant", "Susceptible", "Control")

# Make variables usable for visualization

flies = gather(flies, "Treatment", "EggsLaid")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_boxplot(EggsLaid~Treatment, data=flies, width = 0.4) %>%
  gf_jitter(EggsLaid~Treatment, data=flies, alpha = 0.2, width = 0.1)

```

### Notes on Visualization:

*Line 2: * 

gf_jitter(EggsLaid~Treatment, data=flies, alpha = 0.2, width = 0.1)

**Notes**

I wanted to see the actual points (personal preference) overlaid on the boxplots, so I added them, with a narrow width, and very transparent.

# 23 Butterfat in Dairy Cows

### Overall Goal:  

Compare 5 breeds and age (mature vs. young) cows and the butterfat contents (I'm assuming in the milk they produce)

```{r}
# Read in data

cows = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/BUTTER.DAT")

# Formatting data -----------------------------------------------------------------------

# Break out each breed & label Age of each cow (colnames)

Ayshire = cows %>%
  dplyr::select(V1, V2) %>%
  mutate(Breed = "Ayrshire")

colnames(Ayshire)[1] = "Mature"
colnames(Ayshire)[2] = "Young"

Canadian = cows %>%
  dplyr::select(V3, V4) %>%
  mutate(Breed = "Canadian")

colnames(Canadian)[1] = "Mature"
colnames(Canadian)[2] = "Young"

Guernsey = cows %>%
  dplyr::select(V5, V6) %>%
  mutate(Breed = "Guernsey")

colnames(Guernsey)[1] = "Mature"
colnames(Guernsey)[2] = "Young"

HolsteinFresian = cows %>%
  dplyr::select(V7, V8) %>%
  mutate(Breed = "HolsteinFresian")

colnames(HolsteinFresian)[1] = "Mature"
colnames(HolsteinFresian)[2] = "Young"

Jersey = cows %>%
  dplyr::select(V9, V10) %>%
  mutate(Breed = "Jersey")

colnames(Jersey)[1] = "Mature"
colnames(Jersey)[2] = "Young"

# Combine all datasets

cows = rbind(Ayshire, Canadian, Guernsey, HolsteinFresian, Jersey)

# Make usable variables to visualize

cows = gather(cows, "Age", "Butterfat", 1:2)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_boxplot(Butterfat~fct_reorder(Breed, Butterfat), data=cows, fill=~Age) %>%
  gf_labs(x = "Breed")

```

### Notes on Visualization:

*Line 1: * 

gf_boxplot(Butterfat~fct_reorder(Breed, Butterfat), data=cows, fill=~Age)

**Notes**

I used a simple boxplot here.  I originally though about splitting up breed into separate panels, but it was too hard to compare across breeds.  Here it is much easier to compare across breeds as well as within breed to see the difference between mature & young (seems rather minimal).  In order to easily compare butterfat, I did order the factor so it is in increasing order.  

# 24 Snoring & Heart Disease

### Overall Goal:  

See if there is a relation between the amount of snoring and heart disease.

```{r}
# Read in data

snoring = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/SNORING.DAT")

# Formatting data -----------------------------------------------------------------------

# Renaming Columns

colnames(snoring) = c("None", "Occasional", "NearlyEvery", "EveryNight", "Total")

# Adding the Hear Disease column & making 2 variables from pivoting table

snoring = snoring %>%
  mutate(HeartDisease = c("Yes", "No", "Total")) %>%
  gather(SnoreFreq, Count, 1:4)

# Calculating & Adding a Percent column

snoring = transform(snoring, Percent = ifelse(SnoreFreq == "None", Count/1379, ifelse(SnoreFreq == "Occasional", Count/638, ifelse(SnoreFreq=="NearlyEvery", Count/213, Count/254))))

# Forcing an order for the snoring levels

snoring$SnoreFreq = factor(snoring$SnoreFreq, levels = c("None", "Occasional", "NearlyEvery", "EveryNight"))

# Adjusting the labels for the snoring levels

snoring$SnoreFreq = recode(snoring$SnoreFreq, "NearlyEvery" = "Nearly\nEvery Night", "EveryNight" = "Every Night")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(Percent~SnoreFreq, data=subset(snoring, HeartDisease != "Total"), fill=~HeartDisease) %>%
  gf_labs(y = "Percent Heart Disease", x = "Snore Frequency", fill = "Heart\nDisease", title = "Snoring Impact on Heart Disease") 

```

### Notes on Visualization:

*Line 1: * 

gf_col(Percent~SnoreFreq, data=subset(snoring, HeartDisease != "Total"), fill=~HeartDisease)

**Notes**

Again, since we're given the "weight" for each "bar" - I did a col( ) chart (column) and originally had the raw counts (as is in the table) - but it was too hard to really compare the small "yes" counts and since the sample sizes were drastically different, percents were a better way to go.  I'm assuming there is an easier way to have calculated the percents, nevertheless, I calculated the percents, then plotted those after forcing the order of the snore frequency values.  

# 25 Title

### Overall Goal:  

Text here about goal…

```{r}
# Read in data

trees = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/TREES.DAT")

# Formatting data -----------------------------------------------------------------------

trees = trees %>%
  rename(RedOak = V1, WhiteOak = V2, BlackOak = V3, Hickory = V4, Maple = V5, Other = V6, Total = V7) %>%
  mutate(Species = c("Red Oak", "White Oak", "Black Oak", "Hickory", "Maple", "Other")) %>%
  gather(NeighborTree, Count, 1:6) 

trees$NeighborTree = recode(trees$NeighborTree, "RedOak" = "Red Oak", "WhiteOak" = "White Oak", "BlackOak" = "Black Oak")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_tile(Species~NeighborTree, fill=~Count, data=trees) %>%
  gf_refine(scale_fill_viridis(direction = -1)) %>%
  gf_labs(x = "Neightbor Tree", fill="Number\nof Trees", title="Tree Nearest Neighbors")

```

### Notes on Visualization:

*Line 1: * 

gf_tile(Species~NeighborTree, fill=~Count, data=trees)

**Notes**

I used viridis fill to have a clearer distinction between colors.  I debated altering the order of trees, but decided to just leave it.  Can update to have the same order as the table if desired.

# 26 US Air Pollution

### Overall Goal:  

Explore a number of explanatory variables on a single response

```{r}
# Read in data

air = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/USAIR.DAT")

# Formatting data -----------------------------------------------------------------------

colnames(air) = c("SulferDioxide", "AveAnnualTemp", "ManufacturingEnterprises", "PopulationSize", "AveWindSpeed", "AvePrecip", "AveDaysPrecip")

air = air %>%
  mutate(City = c("Phoenix", "Little Rock", "San Francisco", "Denver", "Hartford", "Wilmington", "WASHINGTON", "Jacksonville", "Miami", "Atlanta", "Chicago", "Indianapolis", "Des Moines", "Wichita", "Louisville", "New Orleans", "Baltimore", "Detroit", "Minneapolis", "Kansas City", "Saint Louis", "Omaha", "Albuquerque", "Albany", "Buffalo", "Cincinnati", "Cleveland", "Columbus", "Philadelphia", "Pittsburgh", "Providence", "Memphis", "Nashville", "Dallas", "Houston", "Salt Lake City", "Norfolk", "Richmond", "Seattle", "Charleston", "Milwaukee")) %>%
  mutate(country.etc = c("AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "FL", "GA", "IL", "IN", "IA", "KS", "KY", "LA", "MD", "MI", "MN", "MO", "MO", "NE", "NM", "NY", "NY", "OH", "OH", "OH", "PA", "PA", "RI", "TN", "TN", "TX", "TX", "UT", "VA", "VA", "WA", "WV", "WI"))

nrow(air)

# Data for drawing map

us_states = map_data("state")

# Data for long & lat of each US city

us.cities = us.cities %>%
  mutate(City = str_sub(name, end = -4))

# Merge datasets to get coords for each relevant city

air.coords = left_join(air, us.cities)

# ---------------------------------------------------------------------------------------

# Visualization 1
# ***************

# Plot of Map

gf_polygon(lat~long, data=us_states, group = ~group, fill=NA, color = "gray") %>%
  gf_point(lat~long, data=air.coords, group = NA, size = ~SulferDioxide, alpha = 0.4) %>%
  gf_refine(coord_map("conic", lat0 = 30)) %>%
  gf_theme(theme_map())
  
# Visualization 2
# ***************

# Relationship between each predictor & response

theme_set(theme_bw())

temp.graph = gf_point(SulferDioxide~AveAnnualTemp, data=air, alpha = 0.4) %>%
  gf_text(label = ~City, data=subset(air, SulferDioxide > 90), hjust = -.1, size = 2) 

man.graph = gf_point(SulferDioxide~ManufacturingEnterprises, data=air, alpha = 0.4) %>%
  gf_text(label = ~City, data=subset(air, SulferDioxide > 95), hjust = 2, size = 2) 

pop.graph = gf_point(SulferDioxide~PopulationSize, data=air, alpha = 0.4) %>%
  gf_text(label = ~City, data=subset(air, SulferDioxide > 95), hjust = 2, size = 2) 

wind.graph = gf_point(SulferDioxide~AveWindSpeed, data=air, alpha = 0.4) %>%
  gf_text(label = ~City, data=subset(air, SulferDioxide > 90), hjust = -.1, size = 2)

precip.graph = gf_point(SulferDioxide~AvePrecip, data=air, alpha = 0.4) %>%
  gf_text(label = ~City, data=subset(air, SulferDioxide > 90), hjust = -.1, size = 2)

daysprecip.graph = gf_point(SulferDioxide~AveDaysPrecip, data=air, alpha = 0.4) %>%
  gf_text(label = ~City, data=subset(air, SulferDioxide > 90), hjust = -.1, size = 2) 
  
  
grid.arrange(temp.graph, man.graph, pop.graph, wind.graph, precip.graph, daysprecip.graph, nrow = 3)

# Visualization 3
# ***************
  
# Attempt at scatterplot matrix

require(GGally)
ggpairs(air[,1:7])

```

### Notes on Visualization 1:

The map I thought was interesting and it can overlay other variables other than response.  The time consuming part of this was entering all the cities as they were not in the original dataset, then assuming the state associated.  I noticed that it went in state-alphabetical-order, in which case I was able to deduce that Jacksonville was FL (this may be more obvious to others). Then, grabbing the city info from the us.cities dataset and then the state map info to graph the US map & coordinates for the major cities.  

### Notes on Visualization 2:

The scatterplots I made to see each of the relationships between the explanatory & the response.  I wanted to see all of them together, so tried making a grid, but it's so hard to see trends this way.  Not the easiest.  I originally labeled so many more points, but then when it was 6-graphs-in-one, it was WAY too hard to read.

### Notes on Visualization 3:

I also tried a scatterplot matrix to see not only the relationship between the explanatory variables on the response but also if you want to check for multicolinearity.  The labels are arguably hard to see though :/

# 27 Acacia Ants

### Overall Goal:  

See if ants prefer differnt species of trees

```{r}
# Read in data

ants = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/ACACIA.DAT")

# Formatting data -----------------------------------------------------------------------

ants = ants %>%
  rename("NotInvaded" = V1, "Invaded" = V2, "Total" = V3) %>%  # Rename columns
  mutate(TreeSpecies = c("A", "B", "Total")) %>% # Add new column
  gather(Invaded, NumTrees, 1:2) # Create 2 new variables to graph

# Switch the default order so Invaded is on "bottom"
ants$Invaded = factor(ants$Invaded, levels = c("NotInvaded", "Invaded"))

# Recode so that the Not Invaded has a space
ants$Invaded = recode(ants$Invaded, "NotInvaded" = "Not Invaded")


# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(NumTrees/Total~TreeSpecies, data=subset(ants, TreeSpecies != "Total"), fill = ~Invaded) %>%
  gf_refine(scale_fill_brewer(palette = "Blues")) %>%
  gf_labs(y = "Percent of Trees Invaded", x = "Acacia Tree Species", title = "Ants prefer Species A")

```

### Notes on Visualization:

*Line 1: * 

gf_col(NumTrees/Total~TreeSpecies, data=subset(ants, TreeSpecies != "Total"), fill = ~Invaded)
  
**Notes**

Again, since we had the percents, I used a column chart, but didn't want to include the total (so omitted in the subset command).  Fill so we can see the percent of each tree that was invaded.

*Line 2: *

gf_refine(scale_fill_brewer(palette = "Blues"))

**Notes**

I chose a different color palette than the default cyan & salmon colors.  Just a personal preference.  


# 28 Vaccination

### Overall Goal:  

See if the different area, method of vaccination, type of needle and vaccine batch affect vaccination effectiveness.

```{r}
# Read in data

vaccine = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/VACCINE.DAT")

# Formatting data -----------------------------------------------------------------------

vaccine = vaccine %>%
  rename("VaccineBatch" = V1, "NumberTested" = V2, "NumberPositive" = V3) %>%
  mutate(TypesOfNeedles = rep(c("Fixed", "Detachable", "Fixed", "NA"), 3), MethodOfVacc = rep(c(rep("Multiple Puncture", 3), "Intradermal"), 3), Area = c(rep("Staffordshire", 4), rep("Cardiff", 4), rep("Sheffield", 4)), PercentPositive = NumberPositive/NumberTested) 

vaccine$TypesOfNeedles = factor(vaccine$TypesOfNeedles, levels = c("NA", "Detachable", "Fixed"))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_point(PercentPositive~TypesOfNeedles|Area, data=vaccine, color = ~TypesOfNeedles) %>%
  gf_text(label = ~VaccineBatch, hjust = 1.5) %>%
  gf_labs(y = "Percent Positive", x = "Types of Needles", color = "Types of Needles")

```

### Notes on Visualization:

I used a point to better see each of the different trials (since there are 2 fixed per area) that you can't see in a column chart as well.  I also wanted to label with the vaccine batch number (just in case that was of interest).  I also decided to treat the TypesOfNeedles & MethodOfVaccination as one-in-the-same since the NA only goes with the Intradermal and the det. & fixed only go with the mult puncture.  If someone wants to go in later with some annotation software - they can manually add the labels for the method at the bottom if desired.  Note, the hjust = 1.5 shifts the label over so you cna see the point & the label.  The default is to have the label on top of the point.  An alternative option is to just have the label AS the point and not have both.  


# 29 Peppers in Glass Houses

### Overall Goal:  

Exploring the growth of peppers with different heating, lighting and CO2, in 2 blocks over 2 years.

```{r}
# Read in data

peppers = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/PEPPERS.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# Transpose the dataset (the t() function is for matrices, so make it a dataframe again)
peppers = data.frame(t(peppers))
colnames(peppers) = c("Heating", "Lighting", "CO2", "Y1B1", "Y1B2", "Y2B1R1", "Y2B1R2", "Y2B2R1", "Y2B2R2")

#Make all these variables numeric
peppers = peppers %>%
  mutate_at(c("Heating", "Lighting", "CO2", "Y1B1", "Y1B2", "Y2B1R1", "Y2B1R2", "Y2B2R1", "Y2B2R2"), as.numeric) 

# Recode 0's and 1's
peppers$Heating = recode(peppers$Heating, '0' = "Standard", '1' = "Supplementary")
peppers$Lighting = recode(peppers$Lighting, '0' = "Standard", '1' = "Supplementary")
peppers$CO2 = recode(peppers$CO2, '0' = "Control", '1' = "Added CO2")

# Make variables usable for visualization
peppers = peppers %>%
  gather(YearBlock, Excess, 4:9) %>%
  mutate(Year = str_sub(YearBlock, 2,2), Block = str_sub(YearBlock, 4, 4))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_point(Excess~Year|Lighting~Heating, data=peppers, color = ~CO2, shape = ~CO2, position = position_dodge(width = 0.2))

```

### Notes on Visualization:

*Line 1: * 

gf_point(Excess~Year|Lighting~Heating, data=peppers, color = ~CO2, shape = ~CO2, position = position_dodge(width = 0.2))

**Notes**

I felt the block was not really necessary to visualize here. There aren't enough observations in each combination to really be able to do a line graph (connecting Year 1 to Year 2 to see how it changes over time).  Therefore, scatterplot was chosen instead.  Heating & Lighing are the columns & rows respectively, and because some points were overlapping, I used the position dodge to make it so the CO2 levels were slightly shifted.  Again, changed both shape and color for easier differentiation.  


# 30 Clinical Trial in Lymphoma

### Overall Goal:  

Compare the efficacy of two treatments for patients with Lymphoma.  Notes:  efficacy in this case would be to have more people in the complete response or partial response groups as opposed to the no change or progression groups.  

```{r}
# Read in data

clinical = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/CLINICAL.DAT")

# Formatting data -----------------------------------------------------------------------

colnames(clinical) = c("BP", "CP", "Total")

response = c("Complete response", "Partial response", "No change", "Progression", "Total")

clinical = clinical %>%
  mutate(Response = response) %>% # add response variable
  gather(Treatment, NumPatients, 1:2) %>% # make separate variables for treatment and count
  dplyr::select(-Total) %>% # drop the Total variable (not needed for visualization)
  subset(Response != "Total") %>% # get rid of "total" from Response (not needed)
  group_by(Treatment) %>% # group by treatment so I can calculate sum and percentage within treatment
  mutate(PercentPatients = 100*NumPatients/sum(NumPatients)) %>% # add column for percent patients to better compare two groups
  mutate(CumPercent = cumsum(PercentPatients)) # calculate cumulative percent so I can add labels at specific spots

clinical$Response = factor(clinical$Response, levels = c("Complete response", "Partial response", "No change",  "Progression"))

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_colh(Treatment~PercentPatients, data=clinical, fill=~Response) %>%
  gf_refine(scale_fill_brewer(palette = "RdYlGn", direction = -1)) %>%
  gf_text(Treatment~(100-CumPercent+PercentPatients/2), label=~round(PercentPatients, digits = 0)) %>%
  gf_labs(x = "Cumulative Percentage of Patients", title = "Comparing Treatments for Lymphoma", subtitle="Labels are percentage of patients in each group")

```

### Notes on Visualization:

*Line 1: * 

gf_colh(Treatment~PercentPatients, data=clinical, fill=~Response)

**Notes**

I wanted to be able to do two things: within each group, see parts-to-a-whole (similar to a pie chart) but also easily compare between treatment groups.  Thus, a horizontal column chart was used.  

*Line 2: *

gf_refine(scale_fill_brewer(palette = "RdYlGn", direction = -1))

**Notes**

I wanted to signify the good/bad of the different responses - thus used a diverging color palette from Brewer.  

*Line 3: *

gf_text(Treatment~(100-CumPercent+PercentPatients/2), label=~round(PercentPatients, digits = 0))

**Notes**

This was tricky.  I wanted to somehow label each segment with the percentage of patients in each group.  The hard part was getting the right "location".  There may have been an easier way, but I essentially took the "reverse cumulative percentage" (100 - cum percent) and then shifted by the "median" of the group (PercentPatients/2) so the label was in the middle.  I'm sure there is a more straightforward way to do this - but this worked for now.  

Note: an alternative approach could be to stagger the columns so they are centered at 0 being scaled to between no change and partial response (e.g. have the green on the + right side and red on the - left side where the change from red to green is the center/0 point).


# 31 Danish Do It Yourself

### Overall Goal:  

How to visualize a 5-way contingency table!?

```{r}
# Read in data

diy = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/DANISH.DAT")

# Formatting data -----------------------------------------------------------------------

# Add 3 explanatory variables response, tenure and work to dataset
diy = diy %>% 
  mutate(response = rep(c("yes", "no"), 6), 
         tenure = rep(c("rent", "rent", "own", "own"), 3),
         work = c(rep("skilled", 4), rep("unskilled", 4), rep("office", 4)))

# Grab just apt columns and add living situation (apt)
apt = diy %>% 
  dplyr::select(-c(V4, V5, V6)) %>%
  mutate(Living = "apartment")

# Change just first 3 column names
colnames(apt)[1:3] = c("Under", "Mid", "Over")

# Grab just house columns and add living situation (house)
house = diy %>%
  dplyr::select(-c(V1, V2, V3)) %>%
  mutate(Living = "house")

# Change just the first 3 column names
colnames(house)[1:3] = c("Under", "Mid", "Over")

# Combine house & apt datasets & make variable for age.
diy = rbind(apt, house) %>%
  gather(Age, NumPeople, 1:3)

# Recode age variable to have appropriate labels
diy$Age = recode(diy$Age, 'Under' = "< 30", 'Mid' = "31 - 45", 'Over' = "46 +")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

# gf_count(work~Age|tenure~Living, data=diy, color = ~response, size = ~NumPeople, position = position_dodge(width = 0.3))

gf_col(NumPeople~Age|tenure~Living+work, data=diy, fill=~response) %>%
  gf_theme(axis.text.x=element_text(angle=30, hjust=1)) %>%
  gf_labs(y = "Number of Men", title = "How many men do DIY projects")

```

### Notes on Visualization:

*Line 1: * 

gf_col(NumPeople~Age|tenure~Living+work, data=diy, fill=~response)

**Notes**

I played around with a couple options here - but think the size difference in the bars really lends itself to a better understanding than size of points (in the gf_count version).  I did a lot of faceting here to incorporate all variables.  Ideally we could more easily group the apt & house columns, but this works for now.

*Line 2: *

gf_theme(axis.text.x=element_text(angle=30, hjust=1))

**Notes**

Because the labels for age were so close/overlapped, I shifted the angle rather than make all bars horizontal (another option).  


# 32 Testing Cement

### Overall Goal:  

Compare differences between different gaugers and breakers (both people) in terms of cement mixes.  

```{r}
# Read in data

cement = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/TESTING.DAT")

# Formatting data -----------------------------------------------------------------------

# Add Gauger variable to dataset
cement = cement %>%
  mutate(Gauger = c("Gauger 1", "Gauger 1", "Gauger 2", "Gauger 2", "Gauger 3", "Gauger 3"))

# Get Breaker 1 values & made mini-dataset
b1 = cement %>%
  dplyr::select(V1, V2, Gauger) %>%
  mutate(Breaker = "Breaker 1")

# Same as Breaker 1, but for Breaker 2
b2 = cement %>%
  dplyr::select(V3, V4, Gauger) %>%
  mutate(Breaker = "Breaker 2")

colnames(b2)[1:2] = c("V1", "V2")

# Same as Breaker 1, but for Breaker 3
b3 = cement %>%
  dplyr::select(V5, V6, Gauger) %>%
  mutate(Breaker = "Breaker 3")

colnames(b3)[1:2] = c("V1", "V2")

# Combine all datasets to one
cement = rbind(b1, b2, b3) %>%
  gather(DummyV, Pounds, 1:2) %>%
  dplyr::select(-DummyV)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_boxplot(Pounds~Gauger, data = cement, position = position_dodge(width = 0.3), width = 0.2, color = ~Breaker) 

```

### Notes on Visualization:

*Line 1: * 

gf_boxplot(Pounds~Gauger, data = cement, position = position_dodge(width = 0.3), width = 0.2, color = ~Breaker) 

**Notes**

I also experimented with looking at a scatterplot to see all points - but it was just too messy.  Even adding the lines connecting breakers, just made it too messy.  This was (I found) the clearest/easiest way to view the data - a simple boxplot.


# 33 Irises

### Overall Goal:  

Analyzing the famous Iris dataset!!

```{r}
# Read in data

iris = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/IRISES.DAT")

# Formatting data -----------------------------------------------------------------------

# Grab just the Setosa values & make mini-dataset
Setosa = iris %>%
  dplyr::select(V1, V2, V3, V4) %>%
  mutate(Species = "Setosa")

colnames(Setosa)[1:4] = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")

# Make mini-dataset for just versicolor
Versicolor = iris %>%
  dplyr::select(V5, V6, V7, V8) %>%
  mutate(Species = "Versicolor")

colnames(Versicolor)[1:4] = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")

# Make mini dataset for just Virginica
Virginica = iris %>%
  dplyr::select(V9, V10, V11, V12) %>%
  mutate(Species = "Virginica")

colnames(Virginica)[1:4] = c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")

# Combine all mini datasets to make one
iris = rbind(Setosa, Versicolor, Virginica)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************
theme_set(theme_bw())

ggpairs(iris, aes(color = Species, alpha = 0.3), upper = list(continuous = "density"))

```

### Notes on Visualization:

*Line 1: * 

ggpairs(iris, aes(color = Species, alpha = 0.3), upper = list(continuous = "density"))

**Notes**

I wanted to do something in the ggformula - but really wanted to do a scatterplot matrix, and I don't see a way to do that currently in ggformula.  I like the following for the scatterplots colored by species, the comparison of the different density plots of each species (overlapping plots on the diagonal and stacked plots below).  I also like the boxplots for easy comparison.  I like the idea of doing the density lines for the upper-plots, but they aren't showing all data.  Not sure why the lines aren't showing up for eveyrthing.  Also, the species bargraph is unnecessary.  

Here are some resources I used.

https://www.r-bloggers.com/2021/06/ggpairs-in-r-a-brief-introduction-to-ggpairs/
https://ggobi.github.io/ggally/articles/ggpairs.html

# 34 Water Voles

### Overall Goal:  

Even with the description of the data - I'm not 100% sure what exactly it's measuring and therefore, I am not confident in what visualization to do.  So, I'm doing a heatmap and hoping for the best! 

```{r}
# Read in data

voles = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/VOLES.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# Grab just the percent incidence rows & clean up
perc.incidence = voles[1:13,] %>%
  rowid_to_column("Characteristic") %>% # make column of characteristic value
  gather(Population, Percent, 2:15) %>% # Make population & percent variables 
  mutate(Species = ifelse(Population %in% c("V1", "V2", "V3", "V4", "V5", "V6"), "British", ifelse(Population %in% c("V7", "V8", "V9", "V10", "V11"), "Non British Terrestris", "Non British Sapidus"))) # add Species variable

# Recode to populations
perc.incidence$Population = recode(perc.incidence$Population, 'V1' = "Surrey", "V2" = "Shropshire", "V3" = "Yorkshire", "V4" = "Perthshire", "V5" = "Aberdeen", "V6" = "Eilean Gamhna", "V7" = "Alps", "V8" = "Yugoslavia", "V9" = "Germany", "V10" = "Norway", "V11" = "Pyrenees I", "V12" = "Pyrenees II", "V13" = "North Spain", "V14" = "South Spain")

# Order the same as book
perc.incidence$Population = factor(perc.incidence$Population, levels = c("Surrey", "Shropshire", "Yorkshire", "Perthshire", "Aberdeen", "Eilean Gamhna", "Alps", "Yugoslavia", "Germany", "Norway", "Pyrenees I", "Pyrenees II", "North Spain", "South Spain"))

# Sample size dataset

sample.size = voles[15,] %>%
  gather(Population, SampleSize) %>% # Make population & sample size variables 
  mutate(Species = ifelse(Population %in% c("V1", "V2", "V3", "V4", "V5", "V6"), "British", ifelse(Population %in% c("V7", "V8", "V9", "V10", "V11"), "Non British Terrestris", "Non British Sapidus"))) # add Species variable

# Recode to populations
sample.size$Population = recode(sample.size$Population, 'V1' = "Surrey", "V2" = "Shropshire", "V3" = "Yorkshire", "V4" = "Perthshire", "V5" = "Aberdeen", "V6" = "Eilean Gamhna", "V7" = "Alps", "V8" = "Yugoslavia", "V9" = "Germany", "V10" = "Norway", "V11" = "Pyrenees I", "V12" = "Pyrenees II", "V13" = "North Spain", "V14" = "South Spain")

# Order the same as book
sample.size$Population = factor(sample.size$Population, levels = c("Surrey", "Shropshire", "Yorkshire", "Perthshire", "Aberdeen", "Eilean Gamhna", "Alps", "Yugoslavia", "Germany", "Norway", "Pyrenees I", "Pyrenees II", "North Spain", "South Spain"))

squared.dis = voles[16:28,] %>%
  rowid_to_column("Index") %>% # Add index for the population
  mutate(ComparePop = Index +1) %>% # Create the comparison population group
  gather(Population, SquaredDis, 2:15) %>% # Make the population and squared dissimilarities variables
  mutate(Population = parse_number(Population)) %>% # Make population a number similar to the other comparison population
  na.omit() # Omit the NAs
# ---------------------------------------------------------------------------------------

# Visualization 
# *************

# Percent Incidence

gf_tile(Population~Characteristic, fill=~Percent, data=perc.incidence) %>%
  gf_refine(scale_x_continuous(breaks = c(seq(1:13)))) %>%
  gf_labs(title = "Percent Incidence of Characteristic in Vole Skulls") %>%
  gf_theme(legend.position = "bottom")

# Sample size

gf_col(Population~SampleSize, data=sample.size) %>%
  gf_facet_wrap(Species~., scales = "free_y", nrow = 3) %>%
  gf_labs(title = "Sample size of Voles", x = "Sample Size")


# Squared Dis

gf_tile(ComparePop~Population, data=squared.dis, fill=~SquaredDis) %>% 
  gf_refine(scale_y_reverse(breaks=c(seq(14:1))), scale_x_continuous(breaks = c(seq(1:13)))) %>%
  gf_theme(theme_classic()) %>%
  gf_labs(title = "Matrix of Squared Dissimilarities", y = "Population", fill="Squared\nDissimilarities")

```

### Notes on Visualization 1:

*Line 1: * 

gf_tile(Population~Characteristic, fill=~Percent, data=perc.incidence)
  
**Notes**

Sticking with the ggformula items, I chose again a tile plot to use color for the numerical quantity.  

*Line 2: *

gf_refine(scale_x_continuous(breaks = c(seq(1:13)))) 

**Notes**

I wanted to force the tick marks to be each integer.

*Line 3: *

gf_facet_wrap(Species~., scales = "free_y", nrow = 3)

**Notes**

This code is used to create the panels.  The scales = "free_y" option allows the y axis to only display values that are included in that panel (so it removes the blank ones) and nrow = 3 forces it to print as one column with 3 rows (stacked).

*Line 5: *

gf_theme(legend.position = "bottom")

**Notes**

I just wanted to play around with moving the legend, so put it at the bottom instead of the default right.

### Notes on Visualization 3 (squared dissimilarities graph):

*Line 2: * 

gf_refine(scale_y_reverse(breaks=c(seq(14:1))), scale_x_continuous(breaks = c(seq(1:13))))
  
**Notes**

I wanted to mimic the table in the book, so I reversed the order of the y-axis using the scale_y_reverse() option.  I could not get it to print 14 - 2, so I compromised and did 14-1.  


# 35 Facilities in East Jerusalem

### Overall Goal:  

Explore possible PCA and biplot techniques.  Again, I am pretty unclear about some of the data - so ideally would have more info.

```{r}
# Read in data

facility = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/FACILITY.DAT")

# Formatting data -----------------------------------------------------------------------

facility = facility %>%
  mutate(Facility = c("Toilet", "Kitchen", "Bath", "Electricity", "Water", "Radio", "TV", "Refrigerator")) # Add facility variable

# Make separate mini-datasets for each subgroup
old.city = facility %>%
  dplyr::select(V1, V2, V3, V4, Facility) %>% # select appropriate variables
  mutate(Area = "Old city quarters") %>% # add Area variable
  rename("Christian"= "V1", "Armenian" = "V2", "Jewish" = "V3", "Moslem" = "V4") %>% # rename varaibles (columns)
  gather(SpecArea, Percent, 1:4) %>% # Create specified area & percent variables
  spread(Facility, Percent) # essentially transpose the original talbe so each facility is it's own variable

# mini-dataset for modern 
modern = facility %>%
  dplyr::select(V5, V6, Facility) %>%
  mutate(Area = "Modern") %>%
  rename("AmericanColony" = "V5", "Shaafat" = "V6") %>%
  gather(SpecArea, Percent, 1:2) %>%
  spread(Facility, Percent)

# mini-dataset for other
other = facility %>%
  dplyr::select(V7, V8, Facility) %>%
  mutate(Area = "Other") %>%
  rename("ATur" = "V7", "Silwan" = "V8") %>%
  gather(SpecArea, Percent, 1:2) %>%
  spread(Facility, Percent)

# mini-dataset for rural
rural = facility %>%
  dplyr::select(V9, Facility) %>%
  mutate(Area = "Rural") %>%
  rename("SurBahar" = "V9") %>%
  gather(SpecArea, Percent, 1) %>%
  spread(Facility, Percent)

# combine all datasets
new.facilities = rbind(old.city, modern, other, rural) 

# Transformed dataset to create an image of the original/given data (before PCA)
facilities.2 = new.facilities %>%
  gather(Facility, Percent, 3:10)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_tile(SpecArea~Facility, fill=~Percent, data=facilities.2) %>%
  gf_facet_wrap(~Area, scales = "free_y", nrow = 4, strip.position = "right") %>%
  gf_labs(y = "Specific Area")

# Principal Component Analysis

pca = prcomp(new.facilities[3:10], center = TRUE, scale = TRUE)
screeplot(pca, type = "lines")

rownames(pca$x) = new.facilities$Area 
biplot(pca, scale = 0)

```

### Notes on Visualization 1:

*Line 1: * 

screeplot(pca, type = "lines")

**Notes**

This plot looks to see how many components are needed to make up "most" of the variability (we can do just fine with the first 2)

*Line 2: * 

biplot(pca, scale = 0)

**Notes**

This plot looks at the first 2 components to see how the different areas are grouped (in addition to having the loadings for each facility).  It can be seen that there are 4 rather distinct groupings for the data.


# 36 Yields of Wheat

### Overall Goal:  

Use multidimensional scaling to draw conclusions about general patterns.

```{r}
# Read in data

wheat = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/WHEAT.DAT")

# Formatting data -----------------------------------------------------------------------

wheat = wheat %>%
  rename("Y1970" = "V1", "Y1971" = "V2", "Y1972" = "V3", "Y1973" = "V4") # rename variables/columns

rownames(wheat) = c("Cambridge", "Cockle Park", "Harpers Adams", "Headley Hall", "Morley", "Myerscough", "Rosemaund", "Seale-Hayne", "Sparsholt", "Sutton Bonington", "Terrington", "Wye") # assign row names (so they remain after MDS analysis)

time.wheat = wheat %>%
  mutate(Site = c("Cambridge", "Cockle Park", "Harpers Adams", "Headley Hall", "Morley", "Myerscough", "Rosemaund", "Seale-Hayne", "Sparsholt", "Sutton Bonington", "Terrington", "Wye")) %>% # Add site variable
  gather(Year, Yield, 1:4) %>% # Make year variable (so I can create a time-series-like-graph)
  mutate(Year = parse_number(Year)) # get rid of the Y from the values

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_line(Yield~Year, data=time.wheat, groups=~Site) %>%
  gf_labs(title = "Hot Mess of a Line Graph")

# Multidimensional scaling

# Way 1 to do mds

d = dist(wheat)
fit = cmdscale(d, eig=TRUE, k=2)

mds.data = data.frame(fit$points) %>%
  rename("Dim1" = "X1", "Dim2" = "X2") 

gf_text(Dim2~Dim1, data=mds.data, label = ~rownames(mds.data)) 

# Way 2 to do mds (doing same thing, just slightly different code)

mds = wheat %>%
  dist() %>%
  cmdscale() %>%
  as_tibble() %>%
  rename("Dim1" = "V1", "Dim2" = "V2") %>%
  mutate(Site = c("Cambridge", "Cockle Park", "Harpers Adams", "Headley Hall", "Morley", "Myerscough", "Rosemaund", "Seale-Hayne", "Sparsholt", "Sutton Bonington", "Terrington", "Wye"))

gf_text(Dim2~Dim1, data=mds, label = ~Site) 

# Adding in clustering

clust = kmeans(mds[,1:2], 2)$cluster %>%
  as.factor()

mds = mds %>%
  mutate(groups = clust)

clusters2 = gf_text(Dim2~Dim1, data=mds, label = ~Site, color=~groups) %>%
  gf_theme(legend.position = "none") %>%
  gf_labs(title = "2 Clusters")

clust = kmeans(mds[,1:2], 3)$cluster %>%
  as.factor()

mds = mds %>%
  mutate(groups = clust)

clusters3 = gf_text(Dim2~Dim1, data=mds, label = ~Site, color=~groups) %>%
  gf_theme(legend.position = "none") %>%
  gf_labs(title = "3 Clusters")

grid.arrange(clusters2, clusters3, nrow = 1)

```

### Notes on Visualization:

*Line 1: * 

gf_text(Dim2~Dim1, data=mds, label = ~Site, color=~groups)

**Notes**

Both graphs (above) are essentially plotting the same data - the new reduced dimension data (from the multidimensional scaling analysis).  The color in both graphs shows the clusters from k-means cluster analysis overlaid with the multidimensional scaling.  I did 2 clusters and 3 just for kicks.  

# 37 WISC Blocks

### Overall Goal:  

Compare if time to complete task differs based on 2 different sets of instructions (start with row or start with corner)

```{r}
# Read in data

blocks = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/BLOCKS.DAT")

# Formatting data -----------------------------------------------------------------------

row = data.frame(t(blocks[1:2,])) %>%
  rename("Time" = "X1", "EFT" = "X2") %>%
  mutate(Direction = "Row")

corner = data.frame(t(blocks[3:4,])) %>%
  rename("Time" = "X3", "EFT" = "X4") %>%
  mutate(Direction = "Corner")

blocks = rbind(row, corner)
# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_point(Time~EFT, data=blocks, color=~Direction) %>%
  gf_facet_wrap(~Direction) %>%
  gf_lm()

gf_point(Time~EFT, data=transform(blocks, Direction = NULL), color = "grey85") %>%
  gf_point(Time~EFT, data=blocks, color=~Direction) %>%
  gf_facet_wrap(~Direction)

```

### Notes on Visualization:

*Line 1: *  

gf_point(Time~EFT, data=transform(blocks, Direction = NULL), color = "grey85") %>%

**Notes**

A scatterplot of JUST Time & EFT in a light grey, but the dataset is a "dummy" dataset that doesn't have any Direction variable.  This allows us to facet & color overlay and keep the original data below. Got the idea from this website: https://ggplot2.tidyverse.org/reference/facet_wrap.html

*Line 2: *  

gf_point(Time~EFT, data=blocks, color=~Direction) %>%

**Notes**

This is where we highlight just the specific Direction groups

*Line 3: *  

gf_facet_wrap(~Direction)

**Notes**

This is where we break plot into different panels.  Could also use |Direction within line 2 (but this way we can add other features into the facet wrap if desired for more complex examples)

# 38 Lung Disease in Cotton Industry

### Overall Goal:  

Explore the prevelance of lung disease among cotton industry workers comparing a variety of different explanatory variables.

```{r}
# Read in data

lung = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/LUNG.DAT")

# Formatting data -----------------------------------------------------------------------

# Adjust column names
colnames(lung) = c("Yes", "No", "Dust", "Race", "Sex", "Smoking", "EmploymentLength")

# Recode all the 1's etc. to be more helpful
lung$Dust = recode(lung$Dust, '1' = "High", '2' = "Medium", '3' = "Low")
lung$Dust = factor(lung$Dust, levels = c("Low", "Medium", "High")) # force order of levels 
lung$Race = recode(lung$Race, '1' = "White", '2' = "Other")
lung$Sex = recode(lung$Sex, '1' = "Male", '2' = "Female")
lung$Smoking = recode(lung$Smoking, "1" = "Smoker", "2" = "Non-smoker")
lung$EmploymentLength = recode(lung$EmploymentLength, "1" = "< 10 years", "2" = "10 - 20 years", "3" = "20+ years")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(Yes/(Yes+No)~Dust|EmploymentLength~Race+Smoking, fill=~Sex, position = position_dodge(), data=lung) %>%
  gf_labs(title = "Prevelance of Lung Cancer", y = "Percent with Lung Cancer")

```

### Notes on Visualization:

*Line 1: * 

gf_col(Yes/(Yes+No)~Dust|EmploymentLength~Race+Smoking, fill=~Sex, position = position_dodge(), data=lung)

**Notes**

I wanted to plot the percentage on the y-axis, so calculated that directly from Yes & No.  Then added the other variables in so that all categorical variables were present.  Decided against line graph since so many combinations had so few observations.

# 39 Tomato Crossing

### Overall Goal:  

See if the data really do show 9:3:3:1 ratio.

```{r}
# Read in data

tomato = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/TOMATO.DAT")

# Formatting data -----------------------------------------------------------------------

tomato = tomato %>%
  rename("Freq" = "V1") %>% # Rename variable
  mutate(Size = c("Tall", "Tall", "Dwarf", "Dwarf", "Total"), # add size variable
         Leaf = c("Cut", "Potato", "Cut", "Potato", "Total")) %>% # add leaf variable
  mutate(ExpCount = as.numeric(c(9/16*1611, 3/16*1611, 3/16*1611, 1/16*1611, ""))) %>% # add expected count
  mutate(Phenotype = paste0(Size, ", ", Leaf)) # add Phenotype (not used)
  
tomato$Size = factor(tomato$Size, levels = c("Tall", "Dwarf")) # force order of size levels

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_line(Freq~Size|Leaf, group = ~Leaf, data=subset(tomato, Size !="Total")) %>%
  gf_line(ExpCount~Size|Leaf, group = ~Leaf, data=subset(tomato, Size !="Total"), linetype = "dotted") %>%
  gf_labs(subtitle = "Compare observed and expected counts for different phenotypes")

```

### Notes on Visualization:

*Line 1: * 

gf_line(Freq~Size|Leaf, group = ~Leaf, data=subset(tomato, Size !="Total")) %>%
  gf_line(ExpCount~Size|Leaf, group = ~Leaf, data=subset(tomato, Size !="Total"), linetype = "dotted")

**Notes**

Just simple lines to show the closeness of the observed (solid line) and expected (dotted lines) counts.


# 40 Coronary Heart Disease

### Overall Goal:  

Explore the relationship between the proportion of prevelence of coronary heart disease, blood pressure, and cholesterol.

```{r}
# Read in data

chd = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/CORONARY.DAT")

# Formatting data -----------------------------------------------------------------------

# Grab data for each of the different types of blood pressure & combine

low = chd[,1:2] %>%
  mutate(Cholesterol = c("< 200", "200 - 219", "220 - 259", "> 259"), # add cholesterol variable
         BloodPressure = "< 127") %>% # add blood pressure value
  rename("r" = "V1", "n" = "V2") # rename columns to be consistent across mini-datasets


mid.low = chd[,3:4] %>%
  mutate(Cholesterol = c("< 200", "200 - 219", "220 - 259", "> 259"),
         BloodPressure = "127 - 146") %>%
  rename("r" = "V3", "n" = "V4")

mid.high = chd[,5:6] %>%
  mutate(Cholesterol = c("< 200", "200 - 219", "220 - 259", "> 259"),
         BloodPressure = "147 - 166") %>%
  rename("r" = "V5", "n" = "V6")

high = chd[,7:8] %>%
  mutate(Cholesterol = c("< 200", "200 - 219", "220 - 259", "> 259"),
         BloodPressure = "> 166") %>%
  rename("r" = "V7", "n" = "V8")

# Combine all mini datasets
chd = rbind(low, mid.low, mid.high, high)

# Force order of cholesterol and blood pressure levels
chd$Cholesterol = factor(chd$Cholesterol, levels = c("< 200", "200 - 219", "220 - 259", "> 259"))
chd$BloodPressure = factor(chd$BloodPressure, levels = c("< 127", "127 - 146", "147 - 166", "> 166"))
# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_tile(Cholesterol~BloodPressure, data=chd, fill=~r/n) %>%
  gf_labs(x = "Blood Pressure", fill="Percent\nCHD", title = "How Prevelant is CHD?")

gf_line(r/n~BloodPressure, data=chd, color = ~Cholesterol, group = ~Cholesterol) %>%
  gf_labs(y = "Percent CHD", x = "Blood Pressure", title = "How Prevelant is CHD?") %>%
  gf_text(r/n~BloodPressure, data=subset(chd, BloodPressure == "> 166"), hjust = -.25, label = ~Cholesterol) %>%
  gf_theme(legend.position = "bottom") %>%
  gf_refine(scale_color_viridis(discrete=TRUE, direction = -1))
```

### Notes on Visualization:

Two ways to visualize the data; color and lines.  The lines work well here since the categorical variable is ordinal.  Probably easier to see here too - and put the labels of the cholesterol right in the plot for easier identification. 


# 41 Toxaemia of Pregnancy

### Overall Goal:  

How does smoking status and class affect signs of toxaemia?

```{r}
# Read in data

tox = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/TOXAEMIA.DAT")

# Formatting data -----------------------------------------------------------------------

tox = tox %>%
  rename("Class" = "V1", "Smoking" = "V2") %>% # rename variables
  mutate(Total = V3+V4+V5+V6) %>% # calculate a total column
  gather(Toxaemia, Count, 3:6) %>% # create a toxaemia variable
  mutate(Percent = Count/Total) # calculate & add percent column

# Recode toxaemia values, smoking values, and force order for toxaemia
tox$Toxaemia = recode(tox$Toxaemia, "V3"="Both"  , "V4" ="Proteinuria" , "V5"= "Hypertension"  , "V6" = "Neither")
tox$Toxaemia = factor(tox$Toxaemia, levels = c("Neither", "Hypertension", "Proteinuria", "Both"))
tox$Smoking = recode(tox$Smoking, '1' = "0", '2' = "1 - 19", '3' = "20+")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(as.factor(Class)~Percent, fill=~Toxaemia, data=tox) %>%
  gf_facet_wrap(~Smoking) %>%
  gf_labs(y = "Class", title = "Toxaemia split by cigarettes per day")

```

### Notes on Visualization:

*Line 1-2: * 

gf_col(as.factor(Class)~Percent, fill=~Toxaemia, data=tox) %>%
  gf_facet_wrap(~Smoking)

**Notes**

I originally did a line graph to see how much different the percentages were - but turns out they aren't much different.  It was really hard to see, so I did a column chart instead.  


# 42 Horse Racing

### Overall Goal:  

Does starting position affect how often a horse will win?

```{r}
# Read in data

horse = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/HORSE.DAT")

# Formatting data -----------------------------------------------------------------------

# Transpose dataset & rename variables
horse = data.frame(t(horse)) %>%
  rename("Position" = "X1", "Wins" = "X2")
  

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_col(Wins~Position, data = horse) %>%
  gf_refine(scale_x_discrete(limits = c(seq(1:8)))) %>%
  gf_labs(title = "Does position affect number of wins?") %>%
  gf_text(x = 1, y = 30, label = "Inside Track") %>%
  gf_text(x = 8, y = 16, label = "Outside Track")

```

### Notes on Visualization:

Simple column chart - only flourish really is adding context to the position 1 and 8 being inside or outside track.



# 43 Saltiness

### Overall Goal:  

Explore distribution of saltiness

```{r}
# Read in data

salt = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/SALT.DAT")

# Formatting data -----------------------------------------------------------------------

# Transpose dataset & rename variables
salt = data.frame(t(salt)) %>%
  rename("Saltiness" = "t.salt.")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_dotplot(~Saltiness, data=salt) %>%
  gf_ash(~Saltiness, data=salt)

gf_density(~Saltiness, data=salt)
```

### Notes on Visualization:

There are SO few observations here - I guess a dotplot would be OK to see each individual, but if they want some kind of picture of density - I added a density plot as well.



# 44 Oral Socialization and Explanation of Illness

### Overall Goal:  

Compare anxiety scores between types of societies wehere explanations of illness are present & absent.

```{r}
# Read in data

illness = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/ILLNESS.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

absent = data.frame(t(illness)) %>%
  dplyr::select(X1) %>%
  na.omit() %>%
  rename("Score" = "X1") %>%
  mutate(Explanations = "Absent")

present = data.frame(t(illness)) %>%
  dplyr::select(X2) %>%
  na.omit() %>%
  rename("Score" = "X2") %>%
  mutate(Explanations = "Present")

illness = rbind(absent, present)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_density(~Score, data=illness, fill=~Explanations, alpha = 0.4)

gf_ash(~Score, data=illness, color=~Explanations, adjust = 2) %>%
  gf_labs(x = "Anxiety Score", title = "Do anxiety scores differ based on explanations of illness?") %>%
  gf_text(x = 8, y = .2, label = "Absent", hjust = 0, color = "coral") %>%
  gf_text(x = 16, y = 0.09, label = "Present", hjust = 0) %>%
  gf_theme(legend.position = "none")
```

### Notes on Visualization:

I wanted to try out this gf_ash (average shifted histograms) and think it looks pretty decent.  You can adjust the smoothness of the lines (I did adjust = 2 instead of the default 1) to smooth things out a bit more and added some labels directly to the plot instead of in a legend.


# 45 Dopamine and Schizophrenia

### Overall Goal:  

Compare dopamine levels between those with and without schizophrenia

```{r}
# Read in data

dopamine = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/DOPAMINE.DAT", header=FALSE)

# Formatting data -----------------------------------------------------------------------

non1 = data.frame(t(dopamine[1,])) %>%
  rename("Dopamine" = "X1") %>%
  mutate(Psychotic = "Nonpsychotic")

non2 = data.frame(t(dopamine[2,])) %>%
  rename("Dopamine" = "X2") %>%
  na.omit() %>%
  mutate(Psychotic = "Nonpsychotic")

yes = data.frame(t(dopamine[3,])) %>%
  rename("Dopamine" = "X3") %>%
  na.omit() %>%
  mutate(Psychotic = "Psychotic")

dopamine = rbind(non1, non2, yes)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_ash(~Dopamine, color = ~Psychotic, data=dopamine, adjust = 2) %>%
  gf_labs(title = "Dopamine levels", subtitle = "Compare those judged with and without schizophrenia") %>%
  gf_text(x = 0.013, y = 85, label = "Nonpsychotic", hjust = 0, color = "coral") %>%
  gf_text(x = 0.025, y = 75, label = "Psychotic", hjust = 0) %>%
  gf_theme(legend.position = "none")

gf_ash(~Dopamine, color = ~Psychotic, data=dopamine, adjust = 2) %>%
  gf_facet_wrap(~Psychotic, nrow = 2)  %>%
  gf_rug(~Dopamine) %>%
  gf_theme(legend.position = "none")

```

### Notes on Visualization:

gf_ash(~Dopamine, color = ~Psychotic, data=dopamine, adjust = 2) %>%
  gf_facet_wrap(~Psychotic, nrow = 2)  %>%
  gf_rug(~Dopamine)

For this, I really just wanted an excuse to try out the gf_rug( ) function which I haven't used yet.  There isn't a ton of data to really compare, but this at least adds a little bit.

# 46 US Cancer

### Overall Goal:  

See how age and cancer prevelance are related over 2 decades.

```{r}
# Read in data

cancer = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/USCANCER.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

# Create mini dataset for 1960 data
cancer60 = subset(cancer[,1:3], V1 != "") %>% # select just 1960 values but not total row
  rename("Age" = "V1") %>% # rename age variable
  mutate(Deaths = parse_number(V2), # get just number for deaths
         Population = parse_number(V3), # get just number for population
         Year = 1960) %>% # add year variable
  dplyr::select(Age, Deaths, Population, Year) # select just the variables I want

# Create mini dataset for 1940 data
cancer40 = subset(cancer[,c(1, 4, 5)], V1 != "") %>%
  rename("Age" = "V1") %>%
  mutate(Deaths = parse_number(V4),
         Population = parse_number(V5), 
         Year = 1940) %>%
  dplyr::select(Age, Deaths, Population, Year)

# Combine datasets together
cancer = rbind(cancer40, cancer60)

cancer$Age = factor(cancer$Age, levels = cancer40$Age) # lazy way to force order I want
# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_line(Deaths/Population*1000~Year, color=~Age, group=~Age, data=cancer) %>%
  gf_text(Deaths/Population*1000~Year, data=subset(cancer, Age %in% c("35-44", "45-54", "55-64", "65-74", "75-84", "85+") & Year == 1960), label = ~Age, hjust = -0.3) %>%
  gf_refine(coord_cartesian(xlim = c(1938, 1965)), scale_x_discrete(limits = c(1940, 1960))) %>%
  gf_theme(legend.position = "none") %>%
  gf_labs(y = "Deaths per Thousand", title = "Cancer deaths change over time by age")

```

### Notes on Visualization:

I wanted to see change over time - so I used a line graph connecting the time points.  To see age, I colored by Age and dynamically labeled the lines for easier interpretation (except for the youngest - I just omitted those).  I also plotted deaths per 1000 people for a rate instead of raw count or proportion.  


# 47 Cholesterol

### Overall Goal:  

Compare cholesterol levels between Type A and Type B behaviors.

```{r}
# Read in data

behav = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/BEHAVE.DAT")

# Formatting data -----------------------------------------------------------------------

TypeA = behav[1:2,] %>%
  mutate(Behavior = "Type A") %>%
  gather(DummyV, Cholesterol, 1:10) %>%
  dplyr::select(Behavior, Cholesterol)

TypeB = behav[3:4,] %>%
  mutate(Behavior = "Type B") %>%
  gather(DummyV, Cholesterol, 1:10) %>%
  dplyr::select(Behavior, Cholesterol)

behav = rbind(TypeA, TypeB)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_ash(~Cholesterol, color = ~Behavior, data=behav, adjust = 2) %>%
  gf_rug(~Cholesterol) %>%
  gf_labs(subtitle = "Type A = urgency & ambition\nType B = relaxed")

```

### Notes on Visualization:

Very similar to previous graphs - I just didn't split up graphs so it was easier to compare the distributions between behavior types.  

# 48 Peanuts

### Overall Goal:  

Compare aflatoxin in peanuts

```{r}
# Read in data

peanuts = read.delim("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/PEANUTS.DAT", header = FALSE)

# Formatting data -----------------------------------------------------------------------

peanuts1 = peanuts[,1:2] %>%
  rename("Y" = "V1", 
         "X" = "V2")
  
peanuts2 = peanuts[,3:4] %>%
  rename("Y" = "V3", 
         "X" = "V4")

peanuts3 = peanuts[,5:6] %>%
  rename("Y" = "V5", 
         "X" = "V6")

peanuts = rbind(peanuts1, peanuts2, peanuts3) %>%
  rename("Aflatoxin" = "X", "Percent" = "Y")
# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_point(Percent~Aflatoxin, data=peanuts) %>%
  gf_lm(color = "black", linetype = "dashed") %>%
  gf_labs(y = "Percent Noncontaminated Peanuts", x = "Levels of Aflatoxin in 120 lb batch")

```

### Notes on Visualization:

Pretty straightforward scatterplot, looked pretty linear, so I added a reference line of best fit based on a simple linear regression model.


# 49 Anscombe's Quartet

### Overall Goal:  

The power of visualization and not just relying on numerical summaries!  Very famous example.

```{r}
# Read in data

anscombe = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/ANSCOMBE.DAT")

# Formatting data -----------------------------------------------------------------------

data1 = anscombe[,1:2] %>%
  rename("X" = "V1", "Y" = "V2")

data2 = anscombe[,c(1,3)] %>%
  rename("X" = "V1", "Y" = "V3")

data3 = anscombe[,c(1,4)] %>%
  rename("X" = "V1", "Y" = "V4")

data4 = anscombe[,5:6] %>%
  rename("X" = "V5", "Y" = "V6")

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

theme_set(theme_bw())

graph1 = gf_point(Y~X, data=data1) %>% gf_lm(color = "gray75", linetype = "dotted")
graph2 = gf_point(Y~X, data=data2) %>% gf_lm(color = "gray75", linetype = "dotted")
graph3 = gf_point(Y~X, data=data3) %>% gf_lm(color = "gray75", linetype = "dotted")
graph4 = gf_point(Y~X, data=data4) %>% gf_lm(color = "gray75", linetype = "dotted")

grid.arrange(graph1, graph2, graph3, graph4, nrow = 2)

```

### Notes on Visualization:

I just replicated the collection of 4 graphs I have seen.  Nothing else fancy.


# 50 Caffeine Taps

### Overall Goal:  

Compare the amount of taps and amount of caffeine.  Three separate samples, not matched/blocked by subject (like similar studies).

```{r}
# Read in data

caffeine = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/CAFFEINE.DAT")

# Formatting data -----------------------------------------------------------------------

caffeine = caffeine %>%
  mutate(ML = c("0 ml", "100 ml", "200 ml")) %>%
  gather(DummyV, Taps, 1:10) %>%
  dplyr::select(ML, Taps)

# ---------------------------------------------------------------------------------------

# Visualization 
# ***************

gf_boxplot(Taps~ML, data=caffeine) %>%
  gf_labs(x = "ml of Caffeine", title = "Caffeine Taps")

```

### Notes on Visualization:

SUper simple boxplot to show more taps with more caffeine.  


# 448 Estimated Adominal Disease Diagnoses

Goal to see how well a classification rule does in coding different abdominal pain.  Results: does pretty well with appendicitis, but non specific abdominal pain & other diseases are much harder to discipher.


```{r, fig.width=7}
abdomen = read.table("https://raw.githubusercontent.com/JedStephens/Handbook-of-Small-Data-Sets/master/ABDOMEN.DAT")
head(abdomen)
colnames(abdomen)=c("TrueClass", "Ab Pain", "Appendicitis", "Other")
names(abdomen)
abdomen = gather(abdomen, "SuggestedClass", "Prob", 2:4)
abdomen$TrueClass = recode(abdomen$TrueClass, '1' = "Nonspecific abdominal pain", '2' = "Acute appendicitis", '3' = "Other diseases")

gf_boxplot(Prob~SuggestedClass|TrueClass, data=abdomen) %>%
  gf_sina(Prob~SuggestedClass|TrueClass, data=abdomen, alpha = 0.3)


```





